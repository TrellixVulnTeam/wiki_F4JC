{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"E-Agle TRT Wiki","title":"E-Agle TRT Wiki"},{"location":"#e-agle-trt-wiki","text":"","title":"E-Agle TRT Wiki"},{"location":"DAS_ECU_hw/DAS_ECU/","text":"DAS+ECU MCU configuration The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1 IMU The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused pin as outputs to avoid them floating. Interrupts INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU. Accelerator The code reading the accelerator must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. Brake Pressure Brakelight The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: - On CH[1,2,3] fixed proportionally to the brake pressure - On CH1 blinking while regen MCU to Raspberry The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory Steering wheel encoder The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select. Wheel encoders The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. Raspberry GPIO It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.# DAS+ECU MCU configuration The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators AD1, 8kHz single channel sampling CRC module Buzzer PWM PWM channel on TIM1 Accelerator The code reading the accelerator must follow EV 2.3,. As per T 11.8: the analog sensors are offsetted on the pedal the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU. Brake Pressure Brakelight The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: On CH[1,2,3] fixed proportionally to the brake pressure On CH1 blinking while regen MCU to Raspberry The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory Steering wheel encoder The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select. Wheel encoders The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement. Raspberry GPIO It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.","title":"DAS+ECU"},{"location":"DAS_ECU_hw/DAS_ECU/#dasecu","text":"","title":"DAS+ECU"},{"location":"DAS_ECU_hw/DAS_ECU/#mcu-configuration","text":"The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 IMU: SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators ADC1, 8kHz single channel sampling Pitot tube pressure reading ADC1/2 CRC module Buzzer PWM PWM channel on TIM1","title":"MCU configuration"},{"location":"DAS_ECU_hw/DAS_ECU/#imu","text":"The IMU used is the Bosch BMI088 accelerometer and gyroscope 6-axis unit. Set the unused pin as outputs to avoid them floating.","title":"IMU"},{"location":"DAS_ECU_hw/DAS_ECU/#interrupts","text":"INT1 new accelerometer data is setted as output of the IMU. INT3 new gyroscope data is setted as output of the IMU.","title":"Interrupts"},{"location":"DAS_ECU_hw/DAS_ECU/#accelerator","text":"The code reading the accelerator must follow EV 2.3,. As per T 11.8: - the analog sensors are offsetted on the pedal - the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU.","title":"Accelerator"},{"location":"DAS_ECU_hw/DAS_ECU/#brake-pressure","text":"","title":"Brake Pressure"},{"location":"DAS_ECU_hw/DAS_ECU/#brakelight","text":"The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: - On CH[1,2,3] fixed proportionally to the brake pressure - On CH1 blinking while regen","title":"Brakelight"},{"location":"DAS_ECU_hw/DAS_ECU/#mcu-to-raspberry","text":"The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory","title":"MCU to Raspberry"},{"location":"DAS_ECU_hw/DAS_ECU/#steering-wheel-encoder","text":"The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select.","title":"Steering wheel encoder"},{"location":"DAS_ECU_hw/DAS_ECU/#wheel-encoders","text":"The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement.","title":"Wheel encoders"},{"location":"DAS_ECU_hw/DAS_ECU/#raspberry-gpio","text":"It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.# DAS+ECU","title":"Raspberry GPIO"},{"location":"DAS_ECU_hw/DAS_ECU/#mcu-configuration_1","text":"The MCU STM32F765VGT6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART3 (same as on nucleo devkit) General timing TIM1 on internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 4 ADC channels, 2 brakes and 2 accelerators ADC2, 8kHz single channel sampling 3 PWM channels for brakelight TIM3 2 CAN full featured busses CAN1,CAN3 SBC communication, UART with hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI2, hardware NSS input DMA to map the MCU RAM to the SPI master EEPROM/SDCARD SPI SPI3 Steering position encoder SPI4 receive only master CRC module Buzzer PWM PWM channel on TIM1 The MCU STM32F446RET6 has the following design requirements and solutions found: External crystal 16MHz RCC HSE Crystal Resonator Debug interface Serial wire Debugger UART communication USART2 General timing TIM1, Clock Source is internal clock Wheels encoder mode timers, 32bit TIM2,TIM5 2 CAN full featured busses CAN1,CAN2 SBC communication, UART with full hardware flow control USART1 SBC communication, SPI full duplex slave mode SPI1, hardware NSS input DMA to map the MCU RAM to the SPI master Steering position encoder SPI3 receive only master EEPROM/SDCARD SPI SPI2 3 PWM channels for brakelight TIM3, Clock Source is internal clock 4 ADC channels, 2 brakes and 2 accelerators AD1, 8kHz single channel sampling CRC module Buzzer PWM PWM channel on TIM1","title":"MCU configuration"},{"location":"DAS_ECU_hw/DAS_ECU/#accelerator_1","text":"The code reading the accelerator must follow EV 2.3,. As per T 11.8: the analog sensors are offsetted on the pedal the incoming signal difference is compared to detect implausability The ACC_S1 is the higher signal, ACC_S2 is the lower signal. A single pole low pass RC filter at a frequency of 16kHz is applied so that the signal can be sampled with low enough aliases up to 8kHz and further downsampled to the required frequency for the controls via digital filters after the ADC in the MCU.","title":"Accelerator"},{"location":"DAS_ECU_hw/DAS_ECU/#brake-pressure_1","text":"","title":"Brake Pressure"},{"location":"DAS_ECU_hw/DAS_ECU/#brakelight_1","text":"The brakelight has 3 lines coming from the MCU and they are intended to be used as follows if in compliance with the rules: On CH[1,2,3] fixed proportionally to the brake pressure On CH1 blinking while regen","title":"Brakelight"},{"location":"DAS_ECU_hw/DAS_ECU/#mcu-to-raspberry_1","text":"The MCU is connected to a Raspberry 40 pin GPIO interface on: UART bidirectional hardware flow control interrupts between the devices can be generated on the RTS CTS line if configured accordingly SPI The Raspberry is the master of the bus The MCU is read using DMA on the internal memory","title":"MCU to Raspberry"},{"location":"DAS_ECU_hw/DAS_ECU/#steering-wheel-encoder_1","text":"The encoders on the wheel is read by the MCU using the SPI master receive only mode with no chip select.","title":"Steering wheel encoder"},{"location":"DAS_ECU_hw/DAS_ECU/#wheel-encoders_1","text":"The wheel ancoders (Left and Rigth) are read using TIM2 and TIM5 respectively in 'encoder mode' and thus the code can just read and reset the internal counter which increments and decrements with the wheel movement.","title":"Wheel encoders"},{"location":"DAS_ECU_hw/DAS_ECU/#raspberry-gpio_1","text":"It has been designed for placing a normal Raspberry PI4 but due to GPIO cross compatibility other such SBC can be used. One option is the Nvidia Xavier which on the GPIOs also has CANRX/TX pins which have been connected to a transceiver to the CAN1 of the car.","title":"Raspberry GPIO"},{"location":"common/about/writing-docs/","text":"Writing Documentation Testing the documentation locally You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker. Ordering pages You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md Diagrams You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] Notes and warnings !!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite Mathematical expressions $x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\) Embedding PDFs < object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Writing Documentation"},{"location":"common/about/writing-docs/#writing-documentation","text":"","title":"Writing Documentation"},{"location":"common/about/writing-docs/#testing-the-documentation-locally","text":"You can test locally the exported documentation using the custom docker image generated by the wiki project. Open a terminal in the root folder of your project Make sure the docs/ folder is present Fetch the documentation image: docker pull eagletrt/wiki:latest Run the autoreloading documentation: docker run --rm \\ -p 8000 :8000 \\ -v $( pwd ) /docs:/wiki/docs/<project-name>:z \\ eagletrt/wiki Tip Live reloading works when testing with docker.","title":"Testing the documentation locally"},{"location":"common/about/writing-docs/#ordering-pages","text":"You can change the order and titles of your pages by configuring a .pages file anywhere in your documentation file tree. For more information on the file format take a look at the official documentation . title: Example nav: - subdirectory - page1.md - page2.md","title":"Ordering pages"},{"location":"common/about/writing-docs/#diagrams","text":"You can draw diagrams with mermaid . ```diagram stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] ``` stateDiagram-v2 [*] --> Still Still --> [*] Still --> Moving Moving --> Still Moving --> Crash Crash --> [*]","title":"Diagrams"},{"location":"common/about/writing-docs/#notes-and-warnings","text":"!!! note This this a note. Note This this a note. !!! warning This this a warning. Warning This this a warning. Supported types are: note abstract , summary , tldr info , todo tip , hint , important success , check , done question , help , faq warning , caution , attention failure , fail , missing danger , error bug example quote , cite","title":"Notes and warnings"},{"location":"common/about/writing-docs/#mathematical-expressions","text":"$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$ \\(x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\)","title":"Mathematical expressions"},{"location":"common/about/writing-docs/#embedding-pdfs","text":"< object data = \"../sample.pdf\" type = \"application/pdf\" style = \"width: 100%; height: 600px\" > < embed src = \"../sample.pdf\" type = \"application/pdf\" /> </ object >","title":"Embedding PDFs"},{"location":"common/shared/can-config/","text":"Configuring of the CAN-bus on ST MCUs On CubeMX Activate the Peripheral In CubeMX, expand the \"Connectivity\" tab on the left pane and click on the CAN interface you wish to activate. A configuration pane will appear on the right; tick the \"Activated\" checkbox. Set the Bit Timing Parameters The sampling of the signal is dictated by a number of parameters that set time constraints for the reading and transmitting instants. The duration of a bit (nominal bit time) is split into four segments: a synchronization segment (SYNC_SEG) to sync all nodes on the network, the first Bit Segment (BS1) to define the location of the sampling point, the second Bit Segment to define the transmit point (BS2), and a resynchronization Jump Width (SJW) that indicates how much segments can be lengthened or shortened to compensate for timing errors or delays. The length of these segments is defined in terms of number of Time Quanta ( \\(t_q\\) ). For a visual representation of the subdivision and the mapping of the values to the registers refer to the image below. To define the duration of a time quanta and the length of the various segments, you need to input your parameters into the \"Configuration\" panel that appeared in CubeMx from the previous step (below the \"Activate\" checkbox\"). If your parameters are still to be defined, use an online calculator such as bittiming.can-wiki.info and fill the form; note that selecting the platform is only needed if you're interested in the register mapping, but in any case this website provides a choice for \"ST Microelectronics bxCAN\" which is our case. Input the clock frequency after checking your Clock Tree in CubeMX for how the relevant bus is configured (in the example below, the bxCAN peripheral is connected to the APB1 bus which is at 54 MHz) and of course that the frequency is high enough to operate at the target link speed. Next, input the desired sample point (the default 87.5% is fine), the SJW duration (the default 1 is fine as well), and the desired bitrate in kbit/s . The calculator will generate a table with valid combinations: copy over the values into CubeMX for the Prescaler, BS1, and BS2 (SYNC_SEG is always of length 1 \\(t_q\\) ) and check that the resulting baud rate is correct. The last operation left to perform in CubeMX is to activate all CAN interrupts in the NVIC array: in the same panel as above, switch to the \"NVIC\" tab and tick all checkboxes. In Your Code Most of the information that follows is available in the source documentation of the stm32fXxx_hal_can.c driver file, so check there should you need any additional detail. However, much of the process outlined there is handled automatically by CubeMX, so this document should simplify your setup by only describing what has effectively to be done, while also using a less schematic and cryptic approach. Create the Callback Functions To register callbacks you need to create the relative functions with the proper names (in the form of HAL_CAN_xxxCallback(...) ). Callback signature Action upon which it is invoked void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 0 and is ready to be read. void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 1 and is ready to be read. void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *) FIFO 0 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *) FIFO 1 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *) Mailbox 0 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *) Mailbox 1 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *) Mailbox 2 is now clear (a pending TX has ended). void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *) An error in the peripheral has occurred. Make sure to properly log the raised error code. Example For your convenience, here is a prepared Error Callback that verbosely logs any error bit that is high in the error code. CAN_error_handler(...) is a custom sample function that prints the message over UART and lights up a red LED. void HAL_CAN_ErrorCallback ( CAN_HandleTypeDef * hcan ) { uint32_t e = hcan -> ErrorCode ; if ( e & HAL_CAN_ERROR_EWG ) CAN_error_handler ( \"Protocol Error Warning\" ); if ( e & HAL_CAN_ERROR_EPV ) CAN_error_handler ( \"Error Passive\" ); if ( e & HAL_CAN_ERROR_BOF ) CAN_error_handler ( \"Bus-off Error\" ); if ( e & HAL_CAN_ERROR_STF ) CAN_error_handler ( \"Stuff Error\" ); if ( e & HAL_CAN_ERROR_FOR ) CAN_error_handler ( \"Form Error\" ); if ( e & HAL_CAN_ERROR_ACK ) CAN_error_handler ( \"ACK Error\" ); if ( e & HAL_CAN_ERROR_BR ) CAN_error_handler ( \"Bit Recessive Error\" ); if ( e & HAL_CAN_ERROR_BD ) CAN_error_handler ( \"Bit Dominant Error\" ); if ( e & HAL_CAN_ERROR_CRC ) CAN_error_handler ( \"CRC Error\" ); if ( e & HAL_CAN_ERROR_RX_FOV0 ) CAN_error_handler ( \"FIFO0 Overrun\" ); if ( e & HAL_CAN_ERROR_RX_FOV1 ) CAN_error_handler ( \"FIFO1 Overrun\" ); if ( e & HAL_CAN_ERROR_TX_ALST0 ) CAN_error_handler ( \"Mailbox 0 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR0 ) CAN_error_handler ( \"Mailbox 0 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST1 ) CAN_error_handler ( \"Mailbox 1 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR1 ) CAN_error_handler ( \"Mailbox 1 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST2 ) CAN_error_handler ( \"Mailbox 2 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR2 ) CAN_error_handler ( \"Mailbox 2 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TIMEOUT ) CAN_error_handler ( \"Timeout Error\" ); if ( e & HAL_CAN_ERROR_NOT_INITIALIZED ) CAN_error_handler ( \"Peripheral not initialized\" ); if ( e & HAL_CAN_ERROR_NOT_READY ) CAN_error_handler ( \"Peripheral not ready\" ); if ( e & HAL_CAN_ERROR_NOT_STARTED ) CAN_error_handler ( \"Peripheral not strated\" ); if ( e & HAL_CAN_ERROR_PARAM ) CAN_error_handler ( \"Parameter Error\" ); } Activate the IRQ Handlers (\"Notifications\") At this point, in order for the code to actually invoke your callbacks, you need to activate the relative so-called Notifications with HAL_CAN_ActivateNotification(CAN_HandleTypeDef *, uint32_t) . Possible values for the IRQ number are, as defined in the driver file: /* Transmit Interrupt */ #define CAN_IT_TX_MAILBOX_EMPTY ((uint32_t)CAN_IER_TMEIE) /*!< Transmit mailbox empty interrupt */ /* Receive Interrupts */ #define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0) /*!< FIFO 0 message pending interrupt */ #define CAN_IT_RX_FIFO0_FULL ((uint32_t)CAN_IER_FFIE0) /*!< FIFO 0 full interrupt */ #define CAN_IT_RX_FIFO0_OVERRUN ((uint32_t)CAN_IER_FOVIE0) /*!< FIFO 0 overrun interrupt */ #define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1) /*!< FIFO 1 message pending interrupt */ #define CAN_IT_RX_FIFO1_FULL ((uint32_t)CAN_IER_FFIE1) /*!< FIFO 1 full interrupt */ #define CAN_IT_RX_FIFO1_OVERRUN ((uint32_t)CAN_IER_FOVIE1) /*!< FIFO 1 overrun interrupt */ /* Operating Mode Interrupts */ #define CAN_IT_WAKEUP ((uint32_t)CAN_IER_WKUIE) /*!< Wake-up interrupt */ #define CAN_IT_SLEEP_ACK ((uint32_t)CAN_IER_SLKIE) /*!< Sleep acknowledge interrupt */ /* Error Interrupts */ #define CAN_IT_ERROR_WARNING ((uint32_t)CAN_IER_EWGIE) /*!< Error warning interrupt */ #define CAN_IT_ERROR_PASSIVE ((uint32_t)CAN_IER_EPVIE) /*!< Error passive interrupt */ #define CAN_IT_BUSOFF ((uint32_t)CAN_IER_BOFIE) /*!< Bus-off interrupt */ #define CAN_IT_LAST_ERROR_CODE ((uint32_t)CAN_IER_LECIE) /*!< Last error code interrupt */ #define CAN_IT_ERROR ((uint32_t)CAN_IER_ERRIE) /*!< Error Interrupt */ Note that IRQ numbers can be OR-ed together and be activated many at once. For instance: HAL_CAN_ActivateNotification ( hcan , CAN_IT_ERROR_WARNING | CAN_IT_ERROR_PASSIVE | CAN_IT_BUSOFF | CAN_IT_LAST_ERROR_CODE | CAN_IT_ERROR ); Activate and Configure the Hardware Filters When a new message is received, CAN nodes can use hardware filters to decide if the message must be copied into SRAM and trigger an IRQ, or if it has to be discarded. The advantage of hardware filters is that unwanted messages don't waste any CPU cycles thus saving potentially a lot of resources, especially on heavy traffic networks with many nodes. STMs are equipped with a number of filter banks, each of which is composed by two 32-bit registers. Each bank can operate in ID Mask Mode or in ID List Mode : in the former, one register acts as the mask and the second as the ID, while in the latter mode, both registers represent IDs of the list. Filter banks can also be configured to operate in 16-bit mode, therefore doubling their capacity (four 16-bit registers instead of two 32-bit registers, which are split in two). In ID Mask mode this yields two pairs of Mask+ID, while in ID List mode, of course, it yields 4 ID registers. For a better understanding of the layout of a filter bank in relation to hardware registers, refer to the image below. ID Mask Mode In this mode the filtering is based on a mask register which tells which bits of the ID register need to be compared with the incoming message ID. For instance, with a mask of 11110000000 and an ID of 01110000000 , only messages whose ID begins with 0111 ( 0x3 ) will be accepted. Some more examples follow. Example Mask: 0b11111111111 ( 0x03FF ) ID: 0b11111111111 ( 0x03FF ) Accepted: only ID == 0x03FF Mask: 0b11111111110 ( 0x03FE ) ID: 0b11111111110 ( 0x03FE ) Accepted: { 0x03FE , 0x03FF } (as bit 0 of the filter is disabled) Mask: 0b11111111000 ( 0x03F8 ) ID: 0b00000000000 ( 0x0000 ) Accepted: ID from 0x000 to 0x007 (as bits 0, 1, 2 of the filter are disabled) ID List Mode In ID List Mode, incoming messages' IDs are simply compared for equality with every element of the list. Code To configure a filter, you need to allocate and populate a CAN_FilterTypeDef struct and pass it by reference to HAL_CAN_ConfigFilter(...) . Its fields are the following: FilterMode : either CAN_FILTERMODE_IDMASK or CAN_FILTERMODE_IDLIST , for the respective modes FilterIdHigh : MSBs of the ID register (or first one of the two 16-bit registers) FilterIdLow : LSBs of the ID register (or second one of the two 16-bit registers) FilterMaskIdHigh : MSBs of the Mask register (or first one of the two 16-bit registers) FilterMaskIdLow : LSBs of the Mask register (or second one of the two 16-bit registers) FilterFIFOAssignment : the queue in which to store messages (a value of CAN_filter_FIFO , e.g. CAN_FILTER_FIFO0 ) FilterBank : index of the filter bank to be initialized FilterScale : CAN_FILTERSCALE_16BIT or CAN_FILTERSCALE_32BIT , for the respective register scale FilterActivation : ENABLE or DISABLE Example A filter that accepts everything would look like this: CAN_FilterTypeDef f ; f . FilterMode = CAN_FILTERMODE_IDMASK ; f . FilterIdLow = 0x0 ; // Meaningless, mask is all 0s f . FilterIdHigh = 0x0 ; // Meaningless, mask is all 0s f . FilterMaskIdHigh = 0x0 ; f . FilterMaskIdLow = 0x0 ; f . FilterFIFOAssignment = CAN_FILTER_FIFO0 ; f . FilterBank = 0 ; f . FilterScale = CAN_FILTERSCALE_32BIT ; f . FilterActivation = ENABLE ; HAL_CAN_ConfigFilter ( hcan , & f ); Final Operations The last step is to actually start the peripheral by calling HAL_CAN_Start(...) . To use it, send messages with HAL_CAN_AddTxMessage(...) after checking for free mailboxes with HAL_CAN_GetTxMailboxesFreeLevel(...) and read received messages with HAL_CAN_GetRxMessage(...) . Should anything not work properly, refer to the next document, CAN-bus Troubleshooting .","title":"CAN-bus Configuration"},{"location":"common/shared/can-config/#configuring-of-the-can-bus-on-st-mcus","text":"","title":"Configuring of the CAN-bus on ST MCUs"},{"location":"common/shared/can-config/#on-cubemx","text":"","title":"On CubeMX"},{"location":"common/shared/can-config/#activate-the-peripheral","text":"In CubeMX, expand the \"Connectivity\" tab on the left pane and click on the CAN interface you wish to activate. A configuration pane will appear on the right; tick the \"Activated\" checkbox.","title":"Activate the Peripheral"},{"location":"common/shared/can-config/#set-the-bit-timing-parameters","text":"The sampling of the signal is dictated by a number of parameters that set time constraints for the reading and transmitting instants. The duration of a bit (nominal bit time) is split into four segments: a synchronization segment (SYNC_SEG) to sync all nodes on the network, the first Bit Segment (BS1) to define the location of the sampling point, the second Bit Segment to define the transmit point (BS2), and a resynchronization Jump Width (SJW) that indicates how much segments can be lengthened or shortened to compensate for timing errors or delays. The length of these segments is defined in terms of number of Time Quanta ( \\(t_q\\) ). For a visual representation of the subdivision and the mapping of the values to the registers refer to the image below. To define the duration of a time quanta and the length of the various segments, you need to input your parameters into the \"Configuration\" panel that appeared in CubeMx from the previous step (below the \"Activate\" checkbox\"). If your parameters are still to be defined, use an online calculator such as bittiming.can-wiki.info and fill the form; note that selecting the platform is only needed if you're interested in the register mapping, but in any case this website provides a choice for \"ST Microelectronics bxCAN\" which is our case. Input the clock frequency after checking your Clock Tree in CubeMX for how the relevant bus is configured (in the example below, the bxCAN peripheral is connected to the APB1 bus which is at 54 MHz) and of course that the frequency is high enough to operate at the target link speed. Next, input the desired sample point (the default 87.5% is fine), the SJW duration (the default 1 is fine as well), and the desired bitrate in kbit/s . The calculator will generate a table with valid combinations: copy over the values into CubeMX for the Prescaler, BS1, and BS2 (SYNC_SEG is always of length 1 \\(t_q\\) ) and check that the resulting baud rate is correct. The last operation left to perform in CubeMX is to activate all CAN interrupts in the NVIC array: in the same panel as above, switch to the \"NVIC\" tab and tick all checkboxes.","title":"Set the Bit Timing Parameters"},{"location":"common/shared/can-config/#in-your-code","text":"Most of the information that follows is available in the source documentation of the stm32fXxx_hal_can.c driver file, so check there should you need any additional detail. However, much of the process outlined there is handled automatically by CubeMX, so this document should simplify your setup by only describing what has effectively to be done, while also using a less schematic and cryptic approach.","title":"In Your Code"},{"location":"common/shared/can-config/#create-the-callback-functions","text":"To register callbacks you need to create the relative functions with the proper names (in the form of HAL_CAN_xxxCallback(...) ). Callback signature Action upon which it is invoked void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 0 and is ready to be read. void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *) A message has been received into FIFO 1 and is ready to be read. void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *) FIFO 0 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *) FIFO 1 has reached its full capacity. The next RX will cause an overrun error. void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *) Mailbox 0 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *) Mailbox 1 is now clear (a pending TX has ended). void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *) Mailbox 2 is now clear (a pending TX has ended). void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *) An error in the peripheral has occurred. Make sure to properly log the raised error code. Example For your convenience, here is a prepared Error Callback that verbosely logs any error bit that is high in the error code. CAN_error_handler(...) is a custom sample function that prints the message over UART and lights up a red LED. void HAL_CAN_ErrorCallback ( CAN_HandleTypeDef * hcan ) { uint32_t e = hcan -> ErrorCode ; if ( e & HAL_CAN_ERROR_EWG ) CAN_error_handler ( \"Protocol Error Warning\" ); if ( e & HAL_CAN_ERROR_EPV ) CAN_error_handler ( \"Error Passive\" ); if ( e & HAL_CAN_ERROR_BOF ) CAN_error_handler ( \"Bus-off Error\" ); if ( e & HAL_CAN_ERROR_STF ) CAN_error_handler ( \"Stuff Error\" ); if ( e & HAL_CAN_ERROR_FOR ) CAN_error_handler ( \"Form Error\" ); if ( e & HAL_CAN_ERROR_ACK ) CAN_error_handler ( \"ACK Error\" ); if ( e & HAL_CAN_ERROR_BR ) CAN_error_handler ( \"Bit Recessive Error\" ); if ( e & HAL_CAN_ERROR_BD ) CAN_error_handler ( \"Bit Dominant Error\" ); if ( e & HAL_CAN_ERROR_CRC ) CAN_error_handler ( \"CRC Error\" ); if ( e & HAL_CAN_ERROR_RX_FOV0 ) CAN_error_handler ( \"FIFO0 Overrun\" ); if ( e & HAL_CAN_ERROR_RX_FOV1 ) CAN_error_handler ( \"FIFO1 Overrun\" ); if ( e & HAL_CAN_ERROR_TX_ALST0 ) CAN_error_handler ( \"Mailbox 0 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR0 ) CAN_error_handler ( \"Mailbox 0 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST1 ) CAN_error_handler ( \"Mailbox 1 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR1 ) CAN_error_handler ( \"Mailbox 1 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TX_ALST2 ) CAN_error_handler ( \"Mailbox 2 TX failure (arbitration lost)\" ); if ( e & HAL_CAN_ERROR_TX_TERR2 ) CAN_error_handler ( \"Mailbox 2 TX failure (tx error)\" ); if ( e & HAL_CAN_ERROR_TIMEOUT ) CAN_error_handler ( \"Timeout Error\" ); if ( e & HAL_CAN_ERROR_NOT_INITIALIZED ) CAN_error_handler ( \"Peripheral not initialized\" ); if ( e & HAL_CAN_ERROR_NOT_READY ) CAN_error_handler ( \"Peripheral not ready\" ); if ( e & HAL_CAN_ERROR_NOT_STARTED ) CAN_error_handler ( \"Peripheral not strated\" ); if ( e & HAL_CAN_ERROR_PARAM ) CAN_error_handler ( \"Parameter Error\" ); }","title":"Create the Callback Functions"},{"location":"common/shared/can-config/#activate-the-irq-handlers-notifications","text":"At this point, in order for the code to actually invoke your callbacks, you need to activate the relative so-called Notifications with HAL_CAN_ActivateNotification(CAN_HandleTypeDef *, uint32_t) . Possible values for the IRQ number are, as defined in the driver file: /* Transmit Interrupt */ #define CAN_IT_TX_MAILBOX_EMPTY ((uint32_t)CAN_IER_TMEIE) /*!< Transmit mailbox empty interrupt */ /* Receive Interrupts */ #define CAN_IT_RX_FIFO0_MSG_PENDING ((uint32_t)CAN_IER_FMPIE0) /*!< FIFO 0 message pending interrupt */ #define CAN_IT_RX_FIFO0_FULL ((uint32_t)CAN_IER_FFIE0) /*!< FIFO 0 full interrupt */ #define CAN_IT_RX_FIFO0_OVERRUN ((uint32_t)CAN_IER_FOVIE0) /*!< FIFO 0 overrun interrupt */ #define CAN_IT_RX_FIFO1_MSG_PENDING ((uint32_t)CAN_IER_FMPIE1) /*!< FIFO 1 message pending interrupt */ #define CAN_IT_RX_FIFO1_FULL ((uint32_t)CAN_IER_FFIE1) /*!< FIFO 1 full interrupt */ #define CAN_IT_RX_FIFO1_OVERRUN ((uint32_t)CAN_IER_FOVIE1) /*!< FIFO 1 overrun interrupt */ /* Operating Mode Interrupts */ #define CAN_IT_WAKEUP ((uint32_t)CAN_IER_WKUIE) /*!< Wake-up interrupt */ #define CAN_IT_SLEEP_ACK ((uint32_t)CAN_IER_SLKIE) /*!< Sleep acknowledge interrupt */ /* Error Interrupts */ #define CAN_IT_ERROR_WARNING ((uint32_t)CAN_IER_EWGIE) /*!< Error warning interrupt */ #define CAN_IT_ERROR_PASSIVE ((uint32_t)CAN_IER_EPVIE) /*!< Error passive interrupt */ #define CAN_IT_BUSOFF ((uint32_t)CAN_IER_BOFIE) /*!< Bus-off interrupt */ #define CAN_IT_LAST_ERROR_CODE ((uint32_t)CAN_IER_LECIE) /*!< Last error code interrupt */ #define CAN_IT_ERROR ((uint32_t)CAN_IER_ERRIE) /*!< Error Interrupt */ Note that IRQ numbers can be OR-ed together and be activated many at once. For instance: HAL_CAN_ActivateNotification ( hcan , CAN_IT_ERROR_WARNING | CAN_IT_ERROR_PASSIVE | CAN_IT_BUSOFF | CAN_IT_LAST_ERROR_CODE | CAN_IT_ERROR );","title":"Activate the IRQ Handlers (\"Notifications\")"},{"location":"common/shared/can-config/#activate-and-configure-the-hardware-filters","text":"When a new message is received, CAN nodes can use hardware filters to decide if the message must be copied into SRAM and trigger an IRQ, or if it has to be discarded. The advantage of hardware filters is that unwanted messages don't waste any CPU cycles thus saving potentially a lot of resources, especially on heavy traffic networks with many nodes. STMs are equipped with a number of filter banks, each of which is composed by two 32-bit registers. Each bank can operate in ID Mask Mode or in ID List Mode : in the former, one register acts as the mask and the second as the ID, while in the latter mode, both registers represent IDs of the list. Filter banks can also be configured to operate in 16-bit mode, therefore doubling their capacity (four 16-bit registers instead of two 32-bit registers, which are split in two). In ID Mask mode this yields two pairs of Mask+ID, while in ID List mode, of course, it yields 4 ID registers. For a better understanding of the layout of a filter bank in relation to hardware registers, refer to the image below.","title":"Activate and Configure the Hardware Filters"},{"location":"common/shared/can-config/#id-mask-mode","text":"In this mode the filtering is based on a mask register which tells which bits of the ID register need to be compared with the incoming message ID. For instance, with a mask of 11110000000 and an ID of 01110000000 , only messages whose ID begins with 0111 ( 0x3 ) will be accepted. Some more examples follow. Example Mask: 0b11111111111 ( 0x03FF ) ID: 0b11111111111 ( 0x03FF ) Accepted: only ID == 0x03FF Mask: 0b11111111110 ( 0x03FE ) ID: 0b11111111110 ( 0x03FE ) Accepted: { 0x03FE , 0x03FF } (as bit 0 of the filter is disabled) Mask: 0b11111111000 ( 0x03F8 ) ID: 0b00000000000 ( 0x0000 ) Accepted: ID from 0x000 to 0x007 (as bits 0, 1, 2 of the filter are disabled)","title":"ID Mask Mode"},{"location":"common/shared/can-config/#id-list-mode","text":"In ID List Mode, incoming messages' IDs are simply compared for equality with every element of the list.","title":"ID List Mode"},{"location":"common/shared/can-config/#code","text":"To configure a filter, you need to allocate and populate a CAN_FilterTypeDef struct and pass it by reference to HAL_CAN_ConfigFilter(...) . Its fields are the following: FilterMode : either CAN_FILTERMODE_IDMASK or CAN_FILTERMODE_IDLIST , for the respective modes FilterIdHigh : MSBs of the ID register (or first one of the two 16-bit registers) FilterIdLow : LSBs of the ID register (or second one of the two 16-bit registers) FilterMaskIdHigh : MSBs of the Mask register (or first one of the two 16-bit registers) FilterMaskIdLow : LSBs of the Mask register (or second one of the two 16-bit registers) FilterFIFOAssignment : the queue in which to store messages (a value of CAN_filter_FIFO , e.g. CAN_FILTER_FIFO0 ) FilterBank : index of the filter bank to be initialized FilterScale : CAN_FILTERSCALE_16BIT or CAN_FILTERSCALE_32BIT , for the respective register scale FilterActivation : ENABLE or DISABLE Example A filter that accepts everything would look like this: CAN_FilterTypeDef f ; f . FilterMode = CAN_FILTERMODE_IDMASK ; f . FilterIdLow = 0x0 ; // Meaningless, mask is all 0s f . FilterIdHigh = 0x0 ; // Meaningless, mask is all 0s f . FilterMaskIdHigh = 0x0 ; f . FilterMaskIdLow = 0x0 ; f . FilterFIFOAssignment = CAN_FILTER_FIFO0 ; f . FilterBank = 0 ; f . FilterScale = CAN_FILTERSCALE_32BIT ; f . FilterActivation = ENABLE ; HAL_CAN_ConfigFilter ( hcan , & f );","title":"Code"},{"location":"common/shared/can-config/#final-operations","text":"The last step is to actually start the peripheral by calling HAL_CAN_Start(...) . To use it, send messages with HAL_CAN_AddTxMessage(...) after checking for free mailboxes with HAL_CAN_GetTxMailboxesFreeLevel(...) and read received messages with HAL_CAN_GetRxMessage(...) . Should anything not work properly, refer to the next document, CAN-bus Troubleshooting .","title":"Final Operations"},{"location":"common/shared/can-debugging/","text":"CAN-bus Troubleshooting Step 1: Check Your Configuration Check that your CubeMX configuration and your code precisely match what is detailed in CAN-bus Configuration . Warning Be sure to activate all error interrupts and log them properly, otherwise you'll have no way of knowing what is failing and how to fix it. Step 2: Follow This Flowchart Find your problem in the flowchart below and more details in the next chapter. Step 3: Find More Details From The Flowchart Look for the paragraph regarding your problem and read through. CAN Transceiver not communicating with the MCU While the CAN bus operates on two differential lines, the MCU uses a serial protocol, for which a transceiver is needed (for instance, an MCP2562) that translates the CAN_H and CAN_L signals into CAN_TX and CAN_RX. Absence of communication with this device causes the HAL_CAN_Start call to fail with a timeout error. Check Check continuity between all relevant pins of the transceiver, the CAN socket, and the MCU pins. Try swapping the transceiver with a new one. Termination resistors not present or of incorrect value On a CAN network it is very important that the bus is terminated on both sides by a 120 \\(\\Omega\\) resistor ( interesting article on why ). Also note that some devices might already incorporate a termination resistor on their end, so pay attention to how many you put. Check Verify that resistors are properly connected to the bus and are of the correct value. Check schematics and datasheets for already-present termination resistors on the connected nodes. Use an oscilloscope to ensure that the quality of the signal is good. List of errors raised by the HAL library CAN errors are defined in the driver file stm32f7xx_hal_can.h as follows: #define HAL_CAN_ERROR_NONE (0x00000000U) /*!< No error */ #define HAL_CAN_ERROR_EWG (0x00000001U) /*!< Protocol Error Warning */ #define HAL_CAN_ERROR_EPV (0x00000002U) /*!< Error Passive */ #define HAL_CAN_ERROR_BOF (0x00000004U) /*!< Bus-off error */ #define HAL_CAN_ERROR_STF (0x00000008U) /*!< Stuff error */ #define HAL_CAN_ERROR_FOR (0x00000010U) /*!< Form error */ #define HAL_CAN_ERROR_ACK (0x00000020U) /*!< Acknowledgment error */ #define HAL_CAN_ERROR_BR (0x00000040U) /*!< Bit recessive error */ #define HAL_CAN_ERROR_BD (0x00000080U) /*!< Bit dominant error */ #define HAL_CAN_ERROR_CRC (0x00000100U) /*!< CRC error */ #define HAL_CAN_ERROR_RX_FOV0 (0x00000200U) /*!< Rx FIFO0 overrun error */ #define HAL_CAN_ERROR_RX_FOV1 (0x00000400U) /*!< Rx FIFO1 overrun error */ #define HAL_CAN_ERROR_TX_ALST0 (0x00000800U) /*!< TxMailbox 0 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR0 (0x00001000U) /*!< TxMailbox 0 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST1 (0x00002000U) /*!< TxMailbox 1 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR1 (0x00004000U) /*!< TxMailbox 1 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST2 (0x00008000U) /*!< TxMailbox 2 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR2 (0x00010000U) /*!< TxMailbox 2 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TIMEOUT (0x00020000U) /*!< Timeout error */ #define HAL_CAN_ERROR_NOT_INITIALIZED (0x00040000U) /*!< Peripheral not initialized */ #define HAL_CAN_ERROR_NOT_READY (0x00080000U) /*!< Peripheral not ready */ #define HAL_CAN_ERROR_NOT_STARTED (0x00100000U) /*!< Peripheral not started */ #define HAL_CAN_ERROR_PARAM (0x00200000U) /*!< Parameter error */ In general, bus-related and protocol-related errors ( protocol error warning, error passive, bus-off, stuff error, form error, ACK error, bit dominant, bit recessive, CRC error ) indicate either an electric problem with the wiring, or an underlying issue with the clock precision or frequency. Check Double check with a multimeter that the bus is wired properly and that any jumpers make good contact. Use an oscilloscope to ensure that the signal is clear from interference and edges are sharp. Connect a logic analyzer to better understand the communication issue at binary level. See the Clock Skew section and double-check that the configured frequencies match the oscillators. Firmware-related errors such as overruns or transmit failures may instead indicate an overly congested network or a mistake by the developer when invoking low-level API calls. Check Test your device with less traffic to ensure that the performance of the MCU is suitable for the application. If you are using only two devices, try connecting a third one to better understand where and how the errors generate. Carefully compare your code with the HAL and ST application notes. Clock Skew ST's MCUs incorporate an internal low-cost 16MHz crystal (called HSI in the clock tree - High Speed Internal ) which is factory calibrated with a precision up to 1%. However, due to its low accuracy especially with temperature variations of the chip, peripherals can often encounter timing problems, in particular if running at higher frequencies generated by the PLL. Check Set-up an external crystal (HSE) and configure the MCU for the correct frequency. Check at runtime that the HSI is not being used as a fallback after a configuration error with a condition like if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_HSE) . Hardware FIFOs or Mailboxes are not properly cleared For MCUs with transmissions managed via mailboxes, the developer enqueues a new message to send by calling HAL_CAN_AddTxMessage(...) and providing as a last argument the address of a uint32_t variable in which the function will store the ID of the first free mailbox found. Errors may arise in two occasions: either the function is being called so frequently that the bus has no time to send and empty a slot, or no one is listening on the bus and the \"Automatic Retransmission\" option is set, making the MCU hang in a loop where it unsuccessfully tries to send messages over and over again. Conversely, reception queues might as well fill up and cause overruns if they are not read often enough or the network is so congested that the MCU cannot keep up. Warning When a CAN message arrives and its ISR is triggered, remember to call HAL_CAN_GetRxMessage(...) to clear the reception slot, otherwise an overrun will occur after few messages. Check If errors happen when transmitting, make sure you are not sending too frequently and either have free mailboxes available (check with HAL_CAN_GetTxMailboxesFreeLevel(...) ) or a software queue to temporarily store your pending packets. If instead they happen upon reception, test your code with as little incoming traffic as possible and try to understand if your MCU and your software architecture match the intended network performance. Always remember to also properly configure your hardware filters in order to only process what's necessary and not waste resources and CPU cycles. A segmentation fault or other error crashes the MCU The ST drivers and HAL library are generally very solid, so I advise to thoroughly check your code for memory leaks (if the MCU runs out of memory it simply stops) or possible sources of segmentation faults such as handling of pointers or calls to low-level functions like memcpy and such. Remember that if the firmware crashes you won't see any error message printed over serial, the processor will just freeze and stop. Check Print debug statements over UART or blink on-board LEDs to make sure your code keeps executing or, in fact, stops after a while. Use your IDE built-in debugging tools to interface with OpenOCD and find the exact instruction on which the crash happens. Filters not configured properly If a message is discarded by a hardware filter you will not receive interrupts of any kind. Warning Disabling filters will cause every message to be discarded, contrary to what you might expect. Check Carefully read the filter configuration section in CAN-bus Configuration and ensure your filters are behaving as you intend. Interrupts not configured properly For interrupts to be raised by the MCU, they need to be properly configured both from CubeMX and in your code. Check Verify that you followed the correct procedure detailed in the Interrupt section in CAN-bus Configuration .","title":"CAN-bus Troubleshooting"},{"location":"common/shared/can-debugging/#can-bus-troubleshooting","text":"","title":"CAN-bus Troubleshooting"},{"location":"common/shared/can-debugging/#step-1-check-your-configuration","text":"Check that your CubeMX configuration and your code precisely match what is detailed in CAN-bus Configuration . Warning Be sure to activate all error interrupts and log them properly, otherwise you'll have no way of knowing what is failing and how to fix it.","title":"Step 1: Check Your Configuration"},{"location":"common/shared/can-debugging/#step-2-follow-this-flowchart","text":"Find your problem in the flowchart below and more details in the next chapter.","title":"Step 2: Follow This Flowchart"},{"location":"common/shared/can-debugging/#step-3-find-more-details-from-the-flowchart","text":"Look for the paragraph regarding your problem and read through.","title":"Step 3: Find More Details From The Flowchart"},{"location":"common/shared/can-debugging/#can-transceiver-not-communicating-with-the-mcu","text":"While the CAN bus operates on two differential lines, the MCU uses a serial protocol, for which a transceiver is needed (for instance, an MCP2562) that translates the CAN_H and CAN_L signals into CAN_TX and CAN_RX. Absence of communication with this device causes the HAL_CAN_Start call to fail with a timeout error. Check Check continuity between all relevant pins of the transceiver, the CAN socket, and the MCU pins. Try swapping the transceiver with a new one.","title":"CAN Transceiver not communicating with the MCU"},{"location":"common/shared/can-debugging/#termination-resistors-not-present-or-of-incorrect-value","text":"On a CAN network it is very important that the bus is terminated on both sides by a 120 \\(\\Omega\\) resistor ( interesting article on why ). Also note that some devices might already incorporate a termination resistor on their end, so pay attention to how many you put. Check Verify that resistors are properly connected to the bus and are of the correct value. Check schematics and datasheets for already-present termination resistors on the connected nodes. Use an oscilloscope to ensure that the quality of the signal is good.","title":"Termination resistors not present or of incorrect value"},{"location":"common/shared/can-debugging/#list-of-errors-raised-by-the-hal-library","text":"CAN errors are defined in the driver file stm32f7xx_hal_can.h as follows: #define HAL_CAN_ERROR_NONE (0x00000000U) /*!< No error */ #define HAL_CAN_ERROR_EWG (0x00000001U) /*!< Protocol Error Warning */ #define HAL_CAN_ERROR_EPV (0x00000002U) /*!< Error Passive */ #define HAL_CAN_ERROR_BOF (0x00000004U) /*!< Bus-off error */ #define HAL_CAN_ERROR_STF (0x00000008U) /*!< Stuff error */ #define HAL_CAN_ERROR_FOR (0x00000010U) /*!< Form error */ #define HAL_CAN_ERROR_ACK (0x00000020U) /*!< Acknowledgment error */ #define HAL_CAN_ERROR_BR (0x00000040U) /*!< Bit recessive error */ #define HAL_CAN_ERROR_BD (0x00000080U) /*!< Bit dominant error */ #define HAL_CAN_ERROR_CRC (0x00000100U) /*!< CRC error */ #define HAL_CAN_ERROR_RX_FOV0 (0x00000200U) /*!< Rx FIFO0 overrun error */ #define HAL_CAN_ERROR_RX_FOV1 (0x00000400U) /*!< Rx FIFO1 overrun error */ #define HAL_CAN_ERROR_TX_ALST0 (0x00000800U) /*!< TxMailbox 0 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR0 (0x00001000U) /*!< TxMailbox 0 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST1 (0x00002000U) /*!< TxMailbox 1 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR1 (0x00004000U) /*!< TxMailbox 1 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TX_ALST2 (0x00008000U) /*!< TxMailbox 2 transmit failure due to arbitration lost */ #define HAL_CAN_ERROR_TX_TERR2 (0x00010000U) /*!< TxMailbox 2 transmit failure due to transmit error */ #define HAL_CAN_ERROR_TIMEOUT (0x00020000U) /*!< Timeout error */ #define HAL_CAN_ERROR_NOT_INITIALIZED (0x00040000U) /*!< Peripheral not initialized */ #define HAL_CAN_ERROR_NOT_READY (0x00080000U) /*!< Peripheral not ready */ #define HAL_CAN_ERROR_NOT_STARTED (0x00100000U) /*!< Peripheral not started */ #define HAL_CAN_ERROR_PARAM (0x00200000U) /*!< Parameter error */ In general, bus-related and protocol-related errors ( protocol error warning, error passive, bus-off, stuff error, form error, ACK error, bit dominant, bit recessive, CRC error ) indicate either an electric problem with the wiring, or an underlying issue with the clock precision or frequency. Check Double check with a multimeter that the bus is wired properly and that any jumpers make good contact. Use an oscilloscope to ensure that the signal is clear from interference and edges are sharp. Connect a logic analyzer to better understand the communication issue at binary level. See the Clock Skew section and double-check that the configured frequencies match the oscillators. Firmware-related errors such as overruns or transmit failures may instead indicate an overly congested network or a mistake by the developer when invoking low-level API calls. Check Test your device with less traffic to ensure that the performance of the MCU is suitable for the application. If you are using only two devices, try connecting a third one to better understand where and how the errors generate. Carefully compare your code with the HAL and ST application notes.","title":"List of errors raised by the HAL library"},{"location":"common/shared/can-debugging/#clock-skew","text":"ST's MCUs incorporate an internal low-cost 16MHz crystal (called HSI in the clock tree - High Speed Internal ) which is factory calibrated with a precision up to 1%. However, due to its low accuracy especially with temperature variations of the chip, peripherals can often encounter timing problems, in particular if running at higher frequencies generated by the PLL. Check Set-up an external crystal (HSE) and configure the MCU for the correct frequency. Check at runtime that the HSI is not being used as a fallback after a configuration error with a condition like if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_HSE) .","title":"Clock Skew"},{"location":"common/shared/can-debugging/#hardware-fifos-or-mailboxes-are-not-properly-cleared","text":"For MCUs with transmissions managed via mailboxes, the developer enqueues a new message to send by calling HAL_CAN_AddTxMessage(...) and providing as a last argument the address of a uint32_t variable in which the function will store the ID of the first free mailbox found. Errors may arise in two occasions: either the function is being called so frequently that the bus has no time to send and empty a slot, or no one is listening on the bus and the \"Automatic Retransmission\" option is set, making the MCU hang in a loop where it unsuccessfully tries to send messages over and over again. Conversely, reception queues might as well fill up and cause overruns if they are not read often enough or the network is so congested that the MCU cannot keep up. Warning When a CAN message arrives and its ISR is triggered, remember to call HAL_CAN_GetRxMessage(...) to clear the reception slot, otherwise an overrun will occur after few messages. Check If errors happen when transmitting, make sure you are not sending too frequently and either have free mailboxes available (check with HAL_CAN_GetTxMailboxesFreeLevel(...) ) or a software queue to temporarily store your pending packets. If instead they happen upon reception, test your code with as little incoming traffic as possible and try to understand if your MCU and your software architecture match the intended network performance. Always remember to also properly configure your hardware filters in order to only process what's necessary and not waste resources and CPU cycles.","title":"Hardware FIFOs or Mailboxes are not properly cleared"},{"location":"common/shared/can-debugging/#a-segmentation-fault-or-other-error-crashes-the-mcu","text":"The ST drivers and HAL library are generally very solid, so I advise to thoroughly check your code for memory leaks (if the MCU runs out of memory it simply stops) or possible sources of segmentation faults such as handling of pointers or calls to low-level functions like memcpy and such. Remember that if the firmware crashes you won't see any error message printed over serial, the processor will just freeze and stop. Check Print debug statements over UART or blink on-board LEDs to make sure your code keeps executing or, in fact, stops after a while. Use your IDE built-in debugging tools to interface with OpenOCD and find the exact instruction on which the crash happens.","title":"A segmentation fault or other error crashes the MCU"},{"location":"common/shared/can-debugging/#filters-not-configured-properly","text":"If a message is discarded by a hardware filter you will not receive interrupts of any kind. Warning Disabling filters will cause every message to be discarded, contrary to what you might expect. Check Carefully read the filter configuration section in CAN-bus Configuration and ensure your filters are behaving as you intend.","title":"Filters not configured properly"},{"location":"common/shared/can-debugging/#interrupts-not-configured-properly","text":"For interrupts to be raised by the MCU, they need to be properly configured both from CubeMX and in your code. Check Verify that you followed the correct procedure detailed in the Interrupt section in CAN-bus Configuration .","title":"Interrupts not configured properly"},{"location":"common/shared/openocd-errors/","text":"OpenOCD errors Error connecting DP: cannot read IDR CONDITIONS The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread. SOLUTION Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the micros' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work? Check if debug is enabled on the project present on the flash If not, start flashing the MCU while resetting it, when openocd stops on Info : Listening on port 3333 for gdb connections , release the reset button. Be quick!! Enable debug in CubeMX -> System Core -> SYS -> Debug -> Serial Wire","title":"OpenOCD Troubleshooting"},{"location":"common/shared/openocd-errors/#openocd-errors","text":"","title":"OpenOCD errors"},{"location":"common/shared/openocd-errors/#error-connecting-dp-cannot-read-idr","text":"","title":"Error connecting DP: cannot read IDR"},{"location":"common/shared/openocd-errors/#conditions","text":"The following conditions can be observed by using a DAPlink programmer. Enable debug mode level >0 for openOCD, this can be done either via: openocd -d3 ...other_parameters... If using the extension cortex-debug in VSCode, by adding: in file openocd.cfg ------- debug_level 3 If the output of openocd contains: Debug: 229 931 cmsis_dap.c:646 cmsis_dap_swd_read_process(): SWD ack not OK @ 0 JUNK Error: 230 932 adi_v5_swd.c:144 swd_connect(): Error connecting DP: cannot read IDR Debug: 231 932 command.c:628 run_command(): Command 'dap init' failed with error code -4 User : 232 932 command.c:694 command_run_line(): Then the problem is likely to be hardware, i.e. the programmer (DAPlink) is unable to connect/talk to the target via SWD. See this mailling list thread.","title":"CONDITIONS"},{"location":"common/shared/openocd-errors/#solution","text":"Check VDD voltages: Do they reach the micro? Are they the correct value? Are there short-circuits to GND ? Check continuity on SWDIO and SWCLK lines Are the micros' pins soldered to the board? Is the micro correctly oriented on the pcb? Check the DAP connection Do the jumper-wires work? Check if debug is enabled on the project present on the flash If not, start flashing the MCU while resetting it, when openocd stops on Info : Listening on port 3333 for gdb connections , release the reset button. Be quick!! Enable debug in CubeMX -> System Core -> SYS -> Debug -> Serial Wire","title":"SOLUTION"},{"location":"data-analysis/00-How-to-get-started/","text":"Get Started Software to download Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for Windows) GitHub setup Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation . Download a repo of the team: Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/data-analysis.git Matlab Setup First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Signal Processing Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019. Run Matlab/Simulink Model Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Get Started"},{"location":"data-analysis/00-How-to-get-started/#get-started","text":"","title":"Get Started"},{"location":"data-analysis/00-How-to-get-started/#software-to-download","text":"Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for Windows)","title":"Software to download"},{"location":"data-analysis/00-How-to-get-started/#github-setup","text":"Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation .","title":"GitHub setup"},{"location":"data-analysis/00-How-to-get-started/#download-a-repo-of-the-team","text":"Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/data-analysis.git","title":"Download a repo of the team:"},{"location":"data-analysis/00-How-to-get-started/#matlab-setup","text":"First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Signal Processing Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019.","title":"Matlab Setup"},{"location":"data-analysis/00-How-to-get-started/#run-matlabsimulink-model","text":"Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Run Matlab/Simulink Model"},{"location":"data-analysis/01-Data-Extraction/","text":"1_Data Extraction The files related to this modality are in the folder 1_Data Extraction and Filtering This mod allow to import data from the telemetry of the car (files .csv) and convert them in file .mat, allowing us to use them also for simulations with our vehicle model. Before running the main.m file, you have to place the files from the telemetry in the folder File_Telemetry(csv) . Place them inside a folder called with the date of the test day and inside this folder name the single manuevre of the car with a understandable name. The file from the telemetry (.csv) are stored in the drive of the team on: /Teams/Racing Team/Track data: ( Click here for the direct link ) Example: File_Telemetry(csv)/2022_08_15/Acceleration Povo #1 Now you can run the main.m file choosing the 1st mode. THE PROCESS IS COMPLITELY AUTOMATIC AND IT'IS DESCRIBED BELOW: The selection of this mode runs the file csv_to_mat.m ; this files calls all the subscripts related to this mod. In the beginning it is shown an interactive menu in which you can choose the single telemetry folder you want to convert. Make sure to select the subfolder of the telemetry called: Parsed otherwise the script fails. For Example a path can be: Then the script runs automatically the function data_loading_csv.m which loads the .csv data and compute the sampling frequencies of each sensor After loading, there is the automatic filtering of the noise performed by the script filtTheData.m which applies a low pass filter. The frequecy of the low pass filter is chosen by using the mode 4 (Fourier Transform). The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter. Then there is Data_estimator.m which extimates some features and parameters from the data of the sensors that can't be measured directly (slip, forces ecc...). This script uses the folder Estimation Function At the end there is the cutting procedure which plots the data and allows you to choose the start and end time you want. With the new procedure you can cut also more then a single piece of data from the .csv file! The procedure is ruled by an interactive menu which ask you every time if you want to cut another piece. To save a piece of data you must always cut!!!! N.B. Always cut head and tails of the data to avoid problems with the GPS!!! At the end of the script the data .csv already processed are automatically deleated by the script if you wanted. The .csv are heavy files so after the compete cutting procedure it is preferable to delete them. Do not delete the folder Test otherwise GitHub will automatically deleate the folder File_Telemetry(csv). To keep track of the data aquired compile the file Data Report.xlsx in the home folder The data elaborated are stored in their filter and unfiltered version in the folder File_Telemetry(mat)","title":"1_Data Extraction"},{"location":"data-analysis/01-Data-Extraction/#1_data-extraction","text":"The files related to this modality are in the folder 1_Data Extraction and Filtering This mod allow to import data from the telemetry of the car (files .csv) and convert them in file .mat, allowing us to use them also for simulations with our vehicle model. Before running the main.m file, you have to place the files from the telemetry in the folder File_Telemetry(csv) . Place them inside a folder called with the date of the test day and inside this folder name the single manuevre of the car with a understandable name. The file from the telemetry (.csv) are stored in the drive of the team on: /Teams/Racing Team/Track data: ( Click here for the direct link ) Example: File_Telemetry(csv)/2022_08_15/Acceleration Povo #1 Now you can run the main.m file choosing the 1st mode. THE PROCESS IS COMPLITELY AUTOMATIC AND IT'IS DESCRIBED BELOW: The selection of this mode runs the file csv_to_mat.m ; this files calls all the subscripts related to this mod. In the beginning it is shown an interactive menu in which you can choose the single telemetry folder you want to convert. Make sure to select the subfolder of the telemetry called: Parsed otherwise the script fails. For Example a path can be: Then the script runs automatically the function data_loading_csv.m which loads the .csv data and compute the sampling frequencies of each sensor After loading, there is the automatic filtering of the noise performed by the script filtTheData.m which applies a low pass filter. The frequecy of the low pass filter is chosen by using the mode 4 (Fourier Transform). The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter. Then there is Data_estimator.m which extimates some features and parameters from the data of the sensors that can't be measured directly (slip, forces ecc...). This script uses the folder Estimation Function At the end there is the cutting procedure which plots the data and allows you to choose the start and end time you want. With the new procedure you can cut also more then a single piece of data from the .csv file! The procedure is ruled by an interactive menu which ask you every time if you want to cut another piece. To save a piece of data you must always cut!!!! N.B. Always cut head and tails of the data to avoid problems with the GPS!!! At the end of the script the data .csv already processed are automatically deleated by the script if you wanted. The .csv are heavy files so after the compete cutting procedure it is preferable to delete them. Do not delete the folder Test otherwise GitHub will automatically deleate the folder File_Telemetry(csv). To keep track of the data aquired compile the file Data Report.xlsx in the home folder The data elaborated are stored in their filter and unfiltered version in the folder File_Telemetry(mat)","title":"1_Data Extraction"},{"location":"data-analysis/02-Data-Analysis/","text":"2_Data Analysis The 2nd mode allow you to load a set of data .mat converted with 1st mode for plotting the main parameters before and after the filtering. With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for plotting both of them overlapped. The path where you can find the files that you have to load is similar to this one: And the file are similar to these one, always in couples _filt.mat and .mat","title":"2_Data Analysis"},{"location":"data-analysis/02-Data-Analysis/#2_data-analysis","text":"The 2nd mode allow you to load a set of data .mat converted with 1st mode for plotting the main parameters before and after the filtering. With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for plotting both of them overlapped. The path where you can find the files that you have to load is similar to this one: And the file are similar to these one, always in couples _filt.mat and .mat","title":"2_Data Analysis"},{"location":"data-analysis/03-Noise-estimation/","text":"3_Noise Estimation This mode is used to make an estimation of the noise on the data acquired by the different sensors on the car. First of all, you are asked from which folder to get the .mat data (NoiseMain.m file). N.B. You can load only subfolders of File_Telemetry(mat) like this one!!! The NoiseComputation.m load the data from the selected folder and compute the noise associated to the front & rear wheel encoder, accelerometer and gyroscope. The loading operation is performed in a cycle allowing you to load also other folders to analyze more data for the noise computation. The noise is evaluated as the difference between the original and the filtered signal. The value of the variance associated to each of these is stored in \"3_Noise Estimation/DataError\". (Make sure to delete all the file in this folder if you want to delete the estiamtion of the noise performed in old data sets) Finally NoiseMean.m calculates the mean of all these variances in order to obtain a statistical estimation of the actual noise interference. These final values are stored in \"3_Noise Estimation/Variance\" and then through the NoisePlot scripts we are able to make a comparison between the real noisy signal and the one obtained by adding random noise with the obtained variances to the filtered signals. Note that all the explained procedure is carried out only for the signals of the acceleration along x, those of the front/left encoders and the one coming from the gyroscope related to the yaw rate. This is due to the fact that only for these signals there is a noise generation block in the vehicle model on Simulink. Subsequent developments may foresee the use of some kind of noise models also for other sensors and signals. The file used in the vehicle model are in the folder \"3_Noise Estimation/Variance\"","title":"3_Noise Estimation"},{"location":"data-analysis/03-Noise-estimation/#3_noise-estimation","text":"This mode is used to make an estimation of the noise on the data acquired by the different sensors on the car. First of all, you are asked from which folder to get the .mat data (NoiseMain.m file). N.B. You can load only subfolders of File_Telemetry(mat) like this one!!! The NoiseComputation.m load the data from the selected folder and compute the noise associated to the front & rear wheel encoder, accelerometer and gyroscope. The loading operation is performed in a cycle allowing you to load also other folders to analyze more data for the noise computation. The noise is evaluated as the difference between the original and the filtered signal. The value of the variance associated to each of these is stored in \"3_Noise Estimation/DataError\". (Make sure to delete all the file in this folder if you want to delete the estiamtion of the noise performed in old data sets) Finally NoiseMean.m calculates the mean of all these variances in order to obtain a statistical estimation of the actual noise interference. These final values are stored in \"3_Noise Estimation/Variance\" and then through the NoisePlot scripts we are able to make a comparison between the real noisy signal and the one obtained by adding random noise with the obtained variances to the filtered signals. Note that all the explained procedure is carried out only for the signals of the acceleration along x, those of the front/left encoders and the one coming from the gyroscope related to the yaw rate. This is due to the fact that only for these signals there is a noise generation block in the vehicle model on Simulink. Subsequent developments may foresee the use of some kind of noise models also for other sensors and signals. The file used in the vehicle model are in the folder \"3_Noise Estimation/Variance\"","title":"3_Noise Estimation"},{"location":"data-analysis/04-Fourier-Transform/","text":"4_Fourier Transform The 4th mode perform the Fourier Transform and Frequency Domain Analysis With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for performing the fourier transform and relative plots. The Fourier Transform is performed to the non filtered data to see where is the true noise spectrum. This plots are useful to see the frequencies of the noise spectrum and are used to decide the more suitable cut off frequencies for the low pass filters used in \"1_Data Extraction and Filtering/Filt/filtTheData\". To decide the cutoff frequency you have to look to the plots and see where the noise is placed and choose a frenquency before the main concentration of noise. The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter.","title":"4_Fourier Transform"},{"location":"data-analysis/04-Fourier-Transform/#4_fourier-transform","text":"The 4th mode perform the Fourier Transform and Frequency Domain Analysis With this mode you can choose with an interactive menu both the raw file .mat or the filtered one and automatically it will load also the other one for performing the fourier transform and relative plots. The Fourier Transform is performed to the non filtered data to see where is the true noise spectrum. This plots are useful to see the frequencies of the noise spectrum and are used to decide the more suitable cut off frequencies for the low pass filters used in \"1_Data Extraction and Filtering/Filt/filtTheData\". To decide the cutoff frequency you have to look to the plots and see where the noise is placed and choose a frenquency before the main concentration of noise. The pedals and the steering wheel have an higher cutoff frequency because they are less affected by the noise, and so with higher cutoff frequencies we are able to reduce the distorsion applied by the filter.","title":"4_Fourier Transform"},{"location":"data-analysis/05-Vehicle_Modules/","text":"Vehicle_Modules (folder) In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description Git submodules The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Vehicle_Modules (folder)"},{"location":"data-analysis/05-Vehicle_Modules/#vehicle_modules-folder","text":"In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description","title":"Vehicle_Modules (folder)"},{"location":"data-analysis/05-Vehicle_Modules/#git-submodules","text":"The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Git submodules"},{"location":"data-analysis/06-Release-Notes/","text":"Release Notes In this section you will find the updates of the model 31/08/2022: Reconstruct the repository from scratch Work in progress Sistemare segnale di torque appena si ha il segnale di corrente inverter Frequenze filtri Estimation files e Controllare script handling curves Cambio ghiera encoder FR, controllare picchi sborati sensore sterzo","title":"Release Notes"},{"location":"data-analysis/06-Release-Notes/#release-notes","text":"In this section you will find the updates of the model 31/08/2022: Reconstruct the repository from scratch","title":"Release Notes"},{"location":"data-analysis/06-Release-Notes/#work-in-progress","text":"Sistemare segnale di torque appena si ha il segnale di corrente inverter Frequenze filtri Estimation files e Controllare script handling curves Cambio ghiera encoder FR, controllare picchi sborati sensore sterzo","title":"Work in progress"},{"location":"data-analysis/Home/","text":"Data Analysis Welcome to the Data Analysis wiki! TABLE OF CONTENTS How to get started Data Extraction and Filtering Mod 1 inports the raw data (.csv) from the telemetry and perform a noise filtering and a cut for the extraction of the relevant part only. From the data acquired from the sensors are also estimated other indirect parameters, such as lateral and longitudinal slip and forces. The data are saved in .mat files Data Analysis (Plot) Mod 2 plots the data .mat elaborated with mode 1 Noise Estimation Mod 3 performs the comparison between the data .mat before and after the filtering aaplied with mod 1. It allows to estimate the main features of the noise of each sensor in order to replicate them in the vehicle model Fourier Transform Mod 4 allows to perform a fourier transform of the data .mat to understand the noise spectrum of each sensor and properly choose an adequate cut-off frequency for the low pass filters used in mod 1 Vehicle Modules Release Notes To work with this repo open and run the file main.m in which you can select the mod!!! The interactive menu for the mod selection is:","title":"Data Analysis"},{"location":"data-analysis/Home/#data-analysis","text":"Welcome to the Data Analysis wiki!","title":"Data Analysis"},{"location":"data-analysis/Home/#table-of-contents","text":"How to get started Data Extraction and Filtering Mod 1 inports the raw data (.csv) from the telemetry and perform a noise filtering and a cut for the extraction of the relevant part only. From the data acquired from the sensors are also estimated other indirect parameters, such as lateral and longitudinal slip and forces. The data are saved in .mat files Data Analysis (Plot) Mod 2 plots the data .mat elaborated with mode 1 Noise Estimation Mod 3 performs the comparison between the data .mat before and after the filtering aaplied with mod 1. It allows to estimate the main features of the noise of each sensor in order to replicate them in the vehicle model Fourier Transform Mod 4 allows to perform a fourier transform of the data .mat to understand the noise spectrum of each sensor and properly choose an adequate cut-off frequency for the low pass filters used in mod 1 Vehicle Modules Release Notes To work with this repo open and run the file main.m in which you can select the mod!!! The interactive menu for the mod selection is:","title":"TABLE OF CONTENTS"},{"location":"fenice-bms-hv-sw/","text":"High-Voltage Battery Management System Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/#high-voltage-battery-management-system","text":"Battery management is a collection of operations that ensure the safety and efficiency of the battery pack. A basic battery management system should constantly measure cell temperatures and voltages along with the total pack current output and check that each of those values is within specification. If anomalies are detected, the battery should be disconnected immediately via the AIRs. A good battery management system is also able to keep the battery in good operating conditions, with the goal of maintaining the expected efficiency of the powertrain. The need of collecting a lot of data from all over the pack has dictated a scattered architecture for the BMS, that uses multiple data acquisition boards (cellboards) and a single control board (mainboard).","title":"High-Voltage Battery Management System"},{"location":"fenice-bms-hv-sw/bootloader/openblt/","text":"OpenBlt Both cellboards' and mainboard's bootloaders are derived from openblt sources -> OpenBlt Github . Actually Core sources and Target specific sources have copied in the BLT folder. The whole bootloader configuration happens in the blt_conf.h header file, exception made for the flashLayout[] variable found in flash.c, where the flash layout is specified. Build and flash the bootloader Building and flashing theese bootloaders is straightforward. Being STM32CubeMX projects, you just need the STM32-for-VSCode extention, build and flash. Done. Build the firmware There are 2 main modification to be done on the firmware side in order to operate with the openblt bootloader. Modify the linker file (.ld file in the root directory) and shift the program in the flash. This can be done by changing the FLASH (rx) (line 63) accordingly with what specified in the previously mentioned flash.c file (eg. ORIGIN = 0x8004000 ). Take care of reducing the flash size too (eg. LENGHT = 496K ). Convert the .bin build file to .srec format. This can be achieved with this tool: arkku/srec . Example: bin2srec -a 0x8004000 (or anithing specified by the linker file) -i %.bin -o %.srec Flash the firmware Both telemetry and steering wheel raspberries are already configured in order to flash by can. You just need to copy the .srec file in the /home/pi/can_flashing/fw folder. Then you need to call the /home/script/can_flashing/scripts/flash_* script in order to flash the mainboard ( flash_mainboard ) or a specific cellboard ( flash_cellboard<n> ). You can also flash all the cellboard together with the flash_cellboard_all script. Those scripts just takes care of rebooting the target board with a specific can message and then calls the bootcommander tool. For how the scripts are written (demmerda e velocemente) the mainboard firmware must be called fenice-bms.srec and the cellboard one must be called cellboard.srec .","title":"OpenBlt"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#openblt","text":"Both cellboards' and mainboard's bootloaders are derived from openblt sources -> OpenBlt Github . Actually Core sources and Target specific sources have copied in the BLT folder. The whole bootloader configuration happens in the blt_conf.h header file, exception made for the flashLayout[] variable found in flash.c, where the flash layout is specified.","title":"OpenBlt"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#build-and-flash-the-bootloader","text":"Building and flashing theese bootloaders is straightforward. Being STM32CubeMX projects, you just need the STM32-for-VSCode extention, build and flash. Done.","title":"Build and flash the bootloader"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#build-the-firmware","text":"There are 2 main modification to be done on the firmware side in order to operate with the openblt bootloader. Modify the linker file (.ld file in the root directory) and shift the program in the flash. This can be done by changing the FLASH (rx) (line 63) accordingly with what specified in the previously mentioned flash.c file (eg. ORIGIN = 0x8004000 ). Take care of reducing the flash size too (eg. LENGHT = 496K ). Convert the .bin build file to .srec format. This can be achieved with this tool: arkku/srec . Example: bin2srec -a 0x8004000 (or anithing specified by the linker file) -i %.bin -o %.srec","title":"Build the firmware"},{"location":"fenice-bms-hv-sw/bootloader/openblt/#flash-the-firmware","text":"Both telemetry and steering wheel raspberries are already configured in order to flash by can. You just need to copy the .srec file in the /home/pi/can_flashing/fw folder. Then you need to call the /home/script/can_flashing/scripts/flash_* script in order to flash the mainboard ( flash_mainboard ) or a specific cellboard ( flash_cellboard<n> ). You can also flash all the cellboard together with the flash_cellboard_all script. Those scripts just takes care of rebooting the target board with a specific can message and then calls the bootcommander tool. For how the scripts are written (demmerda e velocemente) the mainboard firmware must be called fenice-bms.srec and the cellboard one must be called cellboard.srec .","title":"Flash the firmware"},{"location":"fenice-bms-hv-sw/mainboard/","text":"Mainboard The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS. Subsystems There are several subsystems to the Mainboard's firmware: bal : The bal subsystem contains functions of the cell balancing algorithm bal_fsm : The FSM of the balancing algorithm is contained here bms_fsm : The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. cli_bms : All the CLI commands are defined here. config : Generic interface to handle all sorts of configurations current : Current measurement functions energy : Energy measurement and State-of-Charge estimation logic. feedback : Mainboard's feedbacks handler functions and variables pack : Interface for the battery pack hardware control. soc : State of charge estimation functions (not working). timebase : Controls all repeating actions of the firmware.","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#mainboard","text":"The Mainboard is the central control unit of the BMS. It contains a microcontroller that handles two CAN-bus lines for internal and external communications, peripherals such as insulated ADCs, EEPROMs, serial ports, an SD-card and more. The mainboard is responsible for the actuation of the AIRs and contains the shutdown and pre-charge circuits. It also communicates voltages, temperatures, currents, battery status, warnings and errors to the rest of the car via CAN-bus. An integrated serial command-line interface and internal logging are included to help with troubleshooting. The logic of the mainboard is handled by a couple of finite state machines (FSM). The fsm library is used to manage every state machine of the BMS.","title":"Mainboard"},{"location":"fenice-bms-hv-sw/mainboard/#subsystems","text":"There are several subsystems to the Mainboard's firmware: bal : The bal subsystem contains functions of the cell balancing algorithm bal_fsm : The FSM of the balancing algorithm is contained here bms_fsm : The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. cli_bms : All the CLI commands are defined here. config : Generic interface to handle all sorts of configurations current : Current measurement functions energy : Energy measurement and State-of-Charge estimation logic. feedback : Mainboard's feedbacks handler functions and variables pack : Interface for the battery pack hardware control. soc : State of charge estimation functions (not working). timebase : Controls all repeating actions of the firmware.","title":"Subsystems"},{"location":"fenice-bms-hv-sw/mainboard/io/","text":"I/O There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. adc124021 ADC (SPI): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs : 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/io/#io","text":"There are many peripherals and devices connected to the mainboard. Every component that interfaces with the mainboard's microcontroller is listed here: CAN-buses (CAN): A CAN-bus to communicate with the car and an internal isolated bus for handling the cellboards. adc124021 ADC (SPI): Used to measure pack and bus voltages, and is also used to measure the pack current using a shunt resistor. DAHB S/160 Hall-effect sensor (ADC): Used to measure pack current. Less precise than the shunt, included for historic reasons. The unit contains two sensors with different gains to have a broader current range. AIR and pre-charge controls : Three output pins control the actuation of the AIRs (if the shutdown circuit is not latched in the off state) and the pre-charge circuit. Circuit feedbacks (MUX/ADC): 16 multiplexed analog signals coming from the mainboard's circuit. Used to diagnose the circuit and to verify its correct state compared to the BMS state. Some of those feedbacks are not multiplexed to permit the generation of interrupts from them. IMD Status (PWM): The IMD has an output PWM signal that reports its internal state. M95256 EEPROM (SPI): Used to store runtime variables and data, such as state of charge information, balancing threshold and more. SD-card (SPI): An SD-card is included on the mainboard to be used as storage for extended logs. User console (UART): A serial interface is reserved as an user interface to read/write data and execute commands. The cli library is used as an interface. GPIOs : 9 GPIO pins for external stuff.","title":"I/O"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/","text":"Cell Balancing The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL - Off (OFF) The dormant state of the balancing algorithm. - Compute (CMP) Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases: Imbalance computation The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\) Cell selection The cell selection algorithm is very simple: if the imbalance is greater than 0, the cell is selected for discharge - Discharge (DSC) After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s. - Cooldown (COOL) Cooldown. A small period (5-10s) where voltages are","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-balancing","text":"The cell balancing operation is mostly done on the cellboards. However, the mainboard has to compute all the cells that need to be discharged. To synchronize cellboards and the mainboard an FSM is defined: stateDiagram-v2 direction LR [*] --> OFF OFF --> CMP OFF --> OFF CMP --> DSC CMP --> OFF DSC --> COOL DSC --> OFF DSC --> DSC COOL --> CMP COOL--> OFF COOL --> COOL","title":"Cell Balancing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-off-off","text":"The dormant state of the balancing algorithm.","title":"- Off (OFF)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-compute-cmp","text":"Compute phase. This is where the cell selection algorithm is run. If no cells need to be discharged the FSM returns back to the Off state. The compute phase can be triggered manually via the CLI. The algorithm is split in two phases:","title":"- Compute (CMP)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#imbalance-computation","text":"The imbalance is the voltage difference between a given cell and the minimum-voltage cell. In this phase an imbalance array that contains the imbalances of every cell is created. In this case the imbalance is centered around the minimum-voltage plus a threshold, that is the maximum imbalance permitted in the pack. \\(imbalance[i] = \\max(0, voltages[i] \u2212(min\\_voltage + threshold))\\)","title":"Imbalance computation"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#cell-selection","text":"The cell selection algorithm is very simple: if the imbalance is greater than 0, the cell is selected for discharge","title":"Cell selection"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-discharge-dsc","text":"After compute the mainboard sends the list of cells to be discharged to the cellboards that start the actual discharge for a set amount of time. The discharge time depends on configuration but it's in the range from 30 to 120s.","title":"- Discharge (DSC)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bal/#-cooldown-cool","text":"Cooldown. A small period (5-10s) where voltages are","title":"- Cooldown (COOL)"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/","text":"Command Line Interface The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands. Commands volt The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V Parameters all : prints all cell voltages (plus some usefull information about balancing). temp Similarly to the volt command, temp will return the main temperatures of the pack. Parameters all : Prints all battery temperatures. status Returns a summary of the general status of the BMS. errors This command will return a list containing each active errors and its details ts Controls the Tractive System actuation. Parameters on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM. bal Suite of commands that handle the balancing process. Parameters on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff test <board> <cell0 cell1 ... cellN> : starts a balancing cycle in the board on the specified cells soc Return state of charge information Parameters reset : resets the 'last charge' energy meter. current Shows current measurement for all the available sensors. Parameters zero : zeroes the Hall-effect sensors. dmesg Toggles the debug output. This can be quite verbose if enabled. reset Resets the microcontroller. Analogue to pressing the reset button on board. imd Show imd details feedbacks Show feedbacks status watch Repeatedly run a command Parameters <interval ms> <cmd> cell_distr Lets you change the cellboard arrangment into the pork Parameters ``: Show current cellboard distribution <cell0> ... <cellN> : Update cellboard distribution fans Control the pork fans Parameters off : shut down fans <0-100> : sets fans power pack Control low level ts hardware Warning This can lead to dangerous behaviours when the tractive system is connected, be carefull Parameters airn <on/off> : controls the air negative airp <on/off> : controls the air positive precharge <on/off> : controls the precharge relay Easter eggs? Of course","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#command-line-interface","text":"The command line interface of the Mainboard is based on the cli library. It serves as the main interface with the BMS. The CLI is clocked at 115200 baud and uses local echo Warning The CLI runs on UART1, thus it is not compatible with STM32 Nucleo boards that normally use UART2 as the USB serial console. As the name implies, the CLI is based around commands, in a style inspired by Unix consoles. Pressing ? followed by Enter will give a list of legal commands.","title":"Command Line Interface"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#commands","text":"","title":"Commands"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#volt","text":"The volt command returns the main voltages of the battery pack. Example bus.......0.00 V internal..388.8 V average...3.60 V max.......3.70 V min.......3.50 V delta.....0.20 V","title":"volt"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters","text":"all : prints all cell voltages (plus some usefull information about balancing).","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#temp","text":"Similarly to the volt command, temp will return the main temperatures of the pack.","title":"temp"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_1","text":"all : Prints all battery temperatures.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#status","text":"Returns a summary of the general status of the BMS.","title":"status"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#errors","text":"This command will return a list containing each active errors and its details","title":"errors"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#ts","text":"Controls the Tractive System actuation.","title":"ts"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_2","text":"on : generates a TS_ON event on the BMS FSM . off : triggers TS_OFF event on the aforementioned FSM.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#bal","text":"Suite of commands that handle the balancing process.","title":"bal"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_3","text":"on : Triggers an event that enables the BAL FSM . off : Triggers an event that disables balancing. thr : Returns the currently set threshold. thr <millivolts> : Sets the threshold to the value of <millivolts> . Please be gentle with it: it can break bad if you input strange stuff test <board> <cell0 cell1 ... cellN> : starts a balancing cycle in the board on the specified cells","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#soc","text":"Return state of charge information","title":"soc"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_4","text":"reset : resets the 'last charge' energy meter.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#current","text":"Shows current measurement for all the available sensors.","title":"current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_5","text":"zero : zeroes the Hall-effect sensors.","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#dmesg","text":"Toggles the debug output. This can be quite verbose if enabled.","title":"dmesg"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#reset","text":"Resets the microcontroller. Analogue to pressing the reset button on board.","title":"reset"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#imd","text":"Show imd details","title":"imd"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#feedbacks","text":"Show feedbacks status","title":"feedbacks"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#watch","text":"Repeatedly run a command","title":"watch"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_6","text":"<interval ms> <cmd>","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#cell_distr","text":"Lets you change the cellboard arrangment into the pork","title":"cell_distr"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_7","text":"``: Show current cellboard distribution <cell0> ... <cellN> : Update cellboard distribution","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#fans","text":"Control the pork fans","title":"fans"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_8","text":"off : shut down fans <0-100> : sets fans power","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#pack","text":"Control low level ts hardware Warning This can lead to dangerous behaviours when the tractive system is connected, be carefull","title":"pack"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#parameters_9","text":"airn <on/off> : controls the air negative airp <on/off> : controls the air positive precharge <on/off> : controls the precharge relay","title":"Parameters"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_cli/#easter-eggs","text":"Of course","title":"Easter eggs?"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/","text":"Main State Machine The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation. States stateDiagram-v2 direction LR [*] --> Idle Idle --> AirnClose Idle --> Error AirnClose --> Idle AirnClose --> AirnStatus AirnClose --> Error AirnStatus --> Precharge AirnStatus --> Idle AirnStatus --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle - Idle When the TS is off and no fatal errors are present, the BMS is in the Idle state. - AirnClose When the procedure of activation of the Tractive System is requested. Additional feedbacks are checked in order to close the AIR negative. - AirnStatus Checks if the activation of the AIR negative is ok. - Precharge The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the precharge relay and the monitoring of the bus voltage. The bus voltage is periodically confronted with the internal voltage and when they are within 7% of each other the positive AIR is closed and the precharge relay is opened, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle. - TS_On In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time. - Error If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#main-state-machine","text":"The BMS fsm handles the main state machine of the board. It is responsible for the management of the tractive system activation and deactivation.","title":"Main State Machine"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#states","text":"stateDiagram-v2 direction LR [*] --> Idle Idle --> AirnClose Idle --> Error AirnClose --> Idle AirnClose --> AirnStatus AirnClose --> Error AirnStatus --> Precharge AirnStatus --> Idle AirnStatus --> Error Precharge --> On Precharge --> Idle Precharge --> Error On --> Idle On --> Error Error --> Idle","title":"States"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-idle","text":"When the TS is off and no fatal errors are present, the BMS is in the Idle state.","title":"- Idle"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-airnclose","text":"When the procedure of activation of the Tractive System is requested. Additional feedbacks are checked in order to close the AIR negative.","title":"- AirnClose"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-airnstatus","text":"Checks if the activation of the AIR negative is ok.","title":"- AirnStatus"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-precharge","text":"The Precharge procedure is done to turn on the Tractive System. It involves the actuation of the precharge relay and the monitoring of the bus voltage. The bus voltage is periodically confronted with the internal voltage and when they are within 7% of each other the positive AIR is closed and the precharge relay is opened, ending the precharge procedure. The FSM then transitions to the TS_On state. If the bus voltage doesn't rise fast enough, the precharge fails and the FSM goes back to Idle.","title":"- Precharge"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-ts_on","text":"In this state the high-voltage bus external to the battery is powered. This is the state in which the car can run, or the battery can be charged. When the TS_OFF event occurs, the FSM transitions back to Idle, opening both AIRs at the same time.","title":"- TS_On"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/bms_fsm/#-error","text":"If a fatal error is active the BMS is in this state. TS activation requests are ignored. If every fatal error expires, then the BMS returns to Idle and can accept TS on commands again.","title":"- Error"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/","text":"Config The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/config/#config","text":"The config subsystem is a generic configuration manager that handles the storage and retrieval of vairables from an on-board EEPROM, model m95256. The config struct contains all the needed data: struct config { uint32_t version ; uint16_t address ; bool dirty ; size_t size ; void * data ; }; version stores a version string that is used during to verify that the read data is right. By changing the version string the data gets automatically overwritten with default values. The config struct is rendered opaque by the use of the config_t type. This avoids direct access to config 's content.","title":"Config"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/","text":"Current Current measurements involves 2 different sensors, the shunt resistor, measured through the isolated ADC and the 2-channel analog Hall sensor, sampled through internal ADCs. Current zeroing All the 3 measures involve offsets, which are calculated in those situations where the current is 0 (when both AIRs and precharge relay are open). Shunt resistor The value coming from the ADC is converted with this formula: (volt - shunt_offset) / (1e-4f * 500) Hall Sensor High channel The analog signal is read by adc2 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 6.67e-3f) * (volt - high_channel_offset) Low channel The analog signal is read by adc3 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 40e-3f) * (volt - low_channel_offset)","title":"Current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#current","text":"Current measurements involves 2 different sensors, the shunt resistor, measured through the isolated ADC and the 2-channel analog Hall sensor, sampled through internal ADCs.","title":"Current"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#current-zeroing","text":"All the 3 measures involve offsets, which are calculated in those situations where the current is 0 (when both AIRs and precharge relay are open).","title":"Current zeroing"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#shunt-resistor","text":"The value coming from the ADC is converted with this formula: (volt - shunt_offset) / (1e-4f * 500)","title":"Shunt resistor"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#hall-sensor","text":"","title":"Hall Sensor"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#high-channel","text":"The analog signal is read by adc2 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 6.67e-3f) * (volt - high_channel_offset)","title":"High channel"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/current/#low-channel","text":"The analog signal is read by adc3 in DMA mode in a 128 items array. When the current need to be retrieved, those values are averaged. The value is converted with this formula: (499.f / 300.f / 40e-3f) * (volt - low_channel_offset)","title":"Low channel"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/feedback/","text":"Feedback Feedback system is a self check of the car state, used in the bms_fsm . It consists of 19 signals by which is possible to verify the correct behaviour of the fsm and react to changes on the shutdown. 16 of them are multiplexed and 3 are not, in order to react quicker to them. All theese signals are read with an internal ADC (adc1) in order to better interprete their logic state (actually if <2.5V is low, >9.5 is high and everything in between is unsafe)","title":"Feedback"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/feedback/#feedback","text":"Feedback system is a self check of the car state, used in the bms_fsm . It consists of 19 signals by which is possible to verify the correct behaviour of the fsm and react to changes on the shutdown. 16 of them are multiplexed and 3 are not, in order to react quicker to them. All theese signals are read with an internal ADC (adc1) in order to better interprete their logic state (actually if <2.5V is low, >9.5 is high and everything in between is unsafe)","title":"Feedback"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/timebase/","text":"Timebase It sets a timer to tick every 10ms, then sets the respective flag whenever a interval is matched. By calling it's routine function from the main loop is possible to execute the needed code at fixed intervals. Specifically is used to read voltages, current and temperatures, to send periodic can messages and to control fans.","title":"Timebase"},{"location":"fenice-bms-hv-sw/mainboard/subsystems/timebase/#timebase","text":"It sets a timer to tick every 10ms, then sets the respective flag whenever a interval is matched. By calling it's routine function from the main loop is possible to execute the needed code at fixed intervals. Specifically is used to read voltages, current and temperatures, to send periodic can messages and to control fans.","title":"Timebase"},{"location":"fenice-bms-lv/","text":"Low Voltage Battery Management System The aim of the LV-BMS is to provide the necessary voltage supply to makes all low voltages components working, such as: DAS , Steering wheel , Telemetry boards, lights on board, pumps and radiators. Inside its case a (3S1P 4S1P ) LiPo Battery is present, which, when it's completely charged has a capacity of 16.5 Ah and a voltage of 12.45 V . Because of some components need fixed voltages of 12V and 24V, on the PCB are also present two DCDC converter (boost), which can deliver those voltages even with an input of 9V. The main job of the LV-BMS is to turn on or off the LVMS switch, in order to give or not power to the board. Monitoring the voltages and the temperature of the cells, the temperatures of the DCDCs converters, the battery overcurrent and other more parameters, the board can decide autonomously whether open or close the relay connected to the LVMS switch. Another important feature of the board it's the cooling routine, which consists in the pumps and radiator piloting to keep the inverters and the motors in a specific range of temperatures. The currently working branch of the repo is: dev-baremetal . All the main functions are mostly in the directory Lib Important It's advised to check BMS LV State Machine before reading other chapters. Tip Taking a look to the hardware never hurts \ud83e\udd70","title":"Low Voltage Battery Management System"},{"location":"fenice-bms-lv/#low-voltage-battery-management-system","text":"The aim of the LV-BMS is to provide the necessary voltage supply to makes all low voltages components working, such as: DAS , Steering wheel , Telemetry boards, lights on board, pumps and radiators. Inside its case a (3S1P 4S1P ) LiPo Battery is present, which, when it's completely charged has a capacity of 16.5 Ah and a voltage of 12.45 V . Because of some components need fixed voltages of 12V and 24V, on the PCB are also present two DCDC converter (boost), which can deliver those voltages even with an input of 9V. The main job of the LV-BMS is to turn on or off the LVMS switch, in order to give or not power to the board. Monitoring the voltages and the temperature of the cells, the temperatures of the DCDCs converters, the battery overcurrent and other more parameters, the board can decide autonomously whether open or close the relay connected to the LVMS switch. Another important feature of the board it's the cooling routine, which consists in the pumps and radiator piloting to keep the inverters and the motors in a specific range of temperatures. The currently working branch of the repo is: dev-baremetal . All the main functions are mostly in the directory Lib Important It's advised to check BMS LV State Machine before reading other chapters. Tip Taking a look to the hardware never hurts \ud83e\udd70","title":"Low Voltage Battery Management System"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/","text":"Command Line Interface The command line interface of the LV-BMS is based on the cli.h library and is used to communicate via UART peripheral. Parameters: baudrate at 115200 bit/s Pressing ? followed by Enter or just Enter return the command list Command - volts - radiator - pumps - temps - feedbacks - dmesg - reset - can - inv - cooling - errors - ? Commands volts Prints all cell voltages Parameters: status : append to the output also voltage status Possible outputs of voltage status: VOLT OK VOLT UNDER VOLTAGE VOLT OVER VOLTAGE VOLT ERROR Typical output without status parameter Example Cell 1 : 4.142 V Cell 2 : 4.159 V Cell 3 : 4.159 V Total voltage on board : 12.460 V radiator Used to set manually the duty cycle of a radiator, if cooling routine it's disabled, or just to see the status of the radiators and the internal fan inside the case. Parameters: L / R / B / info : select whether to set Left, Right, Both radiator value or just obtain the info about them duty_cycle / off : select a duty cycle from 0 to 1.0 (1.0 corresponds to 100%, and off to 0%) Typical output with info parameter Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Automatic mode : true Internal fan dt : 12.32 % Note Automatic mode tells to the user if the radiators and the internal fan values are set by the inverter temperatures, so they are spinning under the BMS control, or it they are piloted by the steering wheel pumps Used to set manually the pumps power, if cooling routine it's disabled, or just to see the status of the pumps. Parameters: info / p / v : choose whether to see the status of the pumps or set a specific value Note p stands for proportional and it would be followed by a value from 0 to 1.0, in fact the value is multiplied with MAX_OPAMP_OUT v stands for volt and it would be followed by a value from 0 to MAX_OPAMP_OUT , in fact the value represents the analog voltage level at the opamp output value : proportional or analog value choosen if the first parameter choosen is p or v Typical output with info parameter Example Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Automatic mode : false Note When displayed, the first value of the pumps represents the proportionality with the output (1.0 = Max power ), and the second one enclosed in the square brackets is the analog value. Note Automatic mode tells to the user if the pumps value are set by the inverter temperatures, so they are under the BMS control, or it they are piloted by the steering wheel temps Returns the values of the various ADC sensors Example ADC sensors : Current : 2100.950623 [ mA ] Batt1 : 21.113552 [ \u00b0 C ] Batt2 : 20.952381 [ \u00b0 C ] DCDC 12 V : 21.032967 [ \u00b0 C ] DCDC 24 V : 20.952381 [ \u00b0 C ] feedbacks Returns the values of the MCP23017 chip, which holds all of the feedbacks signals Example FB_RELAY : 0 [ GPA0 ] FB_INVERTERS : 0 [ GPA1 ] GPIOA VAL : 0 [ GPA2 ] // useless feedback, held for consistency FB_24 : 0 [ GPA3 ] FB_PUMPS : 0 [ GPA4 ] FB_SHUTDOWN : 0 [ GPA5 ] FB_RADIATORS : 0 [ GPA6 ] FB_FAN : 0 [ GPA7 ] FB_MAIN : 1 [ GPB0 ] FB_PCBS : 0 [ GPB1 ] FB_12 : 0 [ GPB2 ] dmesg Use it if you want to show a debug message reset Invokes HAL_NVIC_SystemReset() and reset the MCU can Trigger some can messages, just for debug: Parameters: volts / cooling / total / current / temp : to send the relative can msg inv Optionally close or open the relays connected to the inverters and prints RFE and FRG values (relays values). With no parameters it just print the status of the pins. Parameters: on / off : close or open the inverter relays Example [ RFE ] : 1 [ FRG ] : 1 cooling Returns the cooling info (fancy way to do radiator info + pumps info ) Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Radiator automatic mode : true Internal fan dt : 12.51 % Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Pumps automatic mode : false errors Returns the error count and, for every set error, the relative id with Example total 5 id ......... .20 ( dcdc12 off ) timestamp ... T + 2286 ( 169801 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313845 id ......... .16 ( radiator ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .1 state ....... warning timeout delta 2147313857 id ......... .17 ( fan ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .21 ( dcdc24 off ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .12 ( open relay ) timestamp ... T + 2299 ( 169788 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313858","title":"Command Line Interface"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#command-line-interface","text":"The command line interface of the LV-BMS is based on the cli.h library and is used to communicate via UART peripheral. Parameters: baudrate at 115200 bit/s Pressing ? followed by Enter or just Enter return the command list Command - volts - radiator - pumps - temps - feedbacks - dmesg - reset - can - inv - cooling - errors - ?","title":"Command Line Interface"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#commands","text":"","title":"Commands"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#volts","text":"Prints all cell voltages","title":"volts"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters","text":"status : append to the output also voltage status Possible outputs of voltage status: VOLT OK VOLT UNDER VOLTAGE VOLT OVER VOLTAGE VOLT ERROR Typical output without status parameter Example Cell 1 : 4.142 V Cell 2 : 4.159 V Cell 3 : 4.159 V Total voltage on board : 12.460 V","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#radiator","text":"Used to set manually the duty cycle of a radiator, if cooling routine it's disabled, or just to see the status of the radiators and the internal fan inside the case.","title":"radiator"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_1","text":"L / R / B / info : select whether to set Left, Right, Both radiator value or just obtain the info about them duty_cycle / off : select a duty cycle from 0 to 1.0 (1.0 corresponds to 100%, and off to 0%) Typical output with info parameter Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Automatic mode : true Internal fan dt : 12.32 % Note Automatic mode tells to the user if the radiators and the internal fan values are set by the inverter temperatures, so they are spinning under the BMS control, or it they are piloted by the steering wheel","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#pumps","text":"Used to set manually the pumps power, if cooling routine it's disabled, or just to see the status of the pumps.","title":"pumps"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_2","text":"info / p / v : choose whether to see the status of the pumps or set a specific value Note p stands for proportional and it would be followed by a value from 0 to 1.0, in fact the value is multiplied with MAX_OPAMP_OUT v stands for volt and it would be followed by a value from 0 to MAX_OPAMP_OUT , in fact the value represents the analog voltage level at the opamp output value : proportional or analog value choosen if the first parameter choosen is p or v Typical output with info parameter Example Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Automatic mode : false Note When displayed, the first value of the pumps represents the proportionality with the output (1.0 = Max power ), and the second one enclosed in the square brackets is the analog value. Note Automatic mode tells to the user if the pumps value are set by the inverter temperatures, so they are under the BMS control, or it they are piloted by the steering wheel","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#temps","text":"Returns the values of the various ADC sensors Example ADC sensors : Current : 2100.950623 [ mA ] Batt1 : 21.113552 [ \u00b0 C ] Batt2 : 20.952381 [ \u00b0 C ] DCDC 12 V : 21.032967 [ \u00b0 C ] DCDC 24 V : 20.952381 [ \u00b0 C ]","title":"temps"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#feedbacks","text":"Returns the values of the MCP23017 chip, which holds all of the feedbacks signals Example FB_RELAY : 0 [ GPA0 ] FB_INVERTERS : 0 [ GPA1 ] GPIOA VAL : 0 [ GPA2 ] // useless feedback, held for consistency FB_24 : 0 [ GPA3 ] FB_PUMPS : 0 [ GPA4 ] FB_SHUTDOWN : 0 [ GPA5 ] FB_RADIATORS : 0 [ GPA6 ] FB_FAN : 0 [ GPA7 ] FB_MAIN : 1 [ GPB0 ] FB_PCBS : 0 [ GPB1 ] FB_12 : 0 [ GPB2 ]","title":"feedbacks"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#dmesg","text":"Use it if you want to show a debug message","title":"dmesg"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#reset","text":"Invokes HAL_NVIC_SystemReset() and reset the MCU","title":"reset"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#can","text":"Trigger some can messages, just for debug:","title":"can"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_3","text":"volts / cooling / total / current / temp : to send the relative can msg","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#inv","text":"Optionally close or open the relays connected to the inverters and prints RFE and FRG values (relays values). With no parameters it just print the status of the pins.","title":"inv"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#parameters_4","text":"on / off : close or open the inverter relays Example [ RFE ] : 1 [ FRG ] : 1","title":"Parameters:"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#cooling","text":"Returns the cooling info (fancy way to do radiator info + pumps info ) Example Radiators status : Left Duty Cycle : 0.35 Right Duty Cycle : 0.35 Is right on : 1 Is left on : 1 Radiator automatic mode : true Internal fan dt : 12.51 % Pumps status Pumps L : 1.00 [ 4.95 V ] R : 1.00 [ 4.95 V ] Pumps automatic mode : false","title":"cooling"},{"location":"fenice-bms-lv/Main%20functions/Command%20Line%20Interface/#errors","text":"Returns the error count and, for every set error, the relative id with Example total 5 id ......... .20 ( dcdc12 off ) timestamp ... T + 2286 ( 169801 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313845 id ......... .16 ( radiator ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .1 state ....... warning timeout delta 2147313857 id ......... .17 ( fan ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .21 ( dcdc24 off ) timestamp ... T + 2298 ( 169789 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313857 id ......... .12 ( open relay ) timestamp ... T + 2299 ( 169788 ms ago ) offset ..... .0 state ....... warning timeout delta 2147313858","title":"errors"},{"location":"fenice-bms-lv/Main%20functions/Cooling/","text":"Cooling One of the main purpouse of the LV-BMS is to control the cooling circuit of the car (composed of radiators and pumps). The operation is performed by changing the duty cycle of the radiators and the pumps power based on the average mean of the two inverter temperatures. The fan inside the case has to cool down the DCDCs, so its speed follows the average mean of them temperatures. Cooling routine It's a function wich takes as input the average mean of the two inverters temperature and set the speed of radiators and the power of the pumps based on a simple curve: \\(y=mx+q\\) Radiators The m factor as follows: \\(m = \\frac{(MAX\\_RADIATOR\\_DT-MIN\\_RADIATOR\\_DT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_RADIATOR_DT is the max duty cycle allowed for the radiator MIN_RADIATOR_DT is the min duty cycle allowed for the radiator MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_RADIATOR_DT value (basically when the radiators need to go to max speed and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_RADIATOR_DT value (basically when radiators need to start cooling at them min duty cycle) The q factor as follows: \\(q = (MIN\\_RADIATOR\\_DT-(MIN\\_INVERTER\\_TEMP*m))\\) Given: Costant Value MAX_RADIATOR_DT 0.9 MIX_RADIATOR_DT 0.8 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Radiator Duty Cycle 0 -0.3 10 -0.1 20 0.1 30 0.3 40 0.5 50 0.7 60 0.9 Note Negative value are carried to zero via sw Pumps The m factor as follows: \\(m = \\frac{(MAX\\_OPAMP\\_OUT-MIN\\_OPAMP\\_OUT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_OPAMP_OUT is the max allowed output voltage given by the opamp wich feeds the pumps MAX_OPAMP_OUT is the min allowed output voltage given by the opamp wich feeds the pumps MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_OPAMP_OUT value (basically when the pumps need to go to max power and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_OPAMP_OUT value (basically when pumps need to start cooling at them min power value) The q factor as follows: \\(q = MIN\\_OPAMP\\_OUT-(MIN\\_INVERTER\\_TEMP*m)\\) Given: Costant Value MAX_OPAMP_OUT 4.95 MIN_OPAMP_OUT 0 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Analog Pumps value 0 -9.9 10 -7.425 20 -4.95 30 -2.475 40 0 50 2.475 60 4.95 Note Negative value are carried to zero via sw","title":"Cooling"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#cooling","text":"One of the main purpouse of the LV-BMS is to control the cooling circuit of the car (composed of radiators and pumps). The operation is performed by changing the duty cycle of the radiators and the pumps power based on the average mean of the two inverter temperatures. The fan inside the case has to cool down the DCDCs, so its speed follows the average mean of them temperatures.","title":"Cooling"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#cooling-routine","text":"It's a function wich takes as input the average mean of the two inverters temperature and set the speed of radiators and the power of the pumps based on a simple curve: \\(y=mx+q\\)","title":"Cooling routine"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#radiators","text":"The m factor as follows: \\(m = \\frac{(MAX\\_RADIATOR\\_DT-MIN\\_RADIATOR\\_DT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_RADIATOR_DT is the max duty cycle allowed for the radiator MIN_RADIATOR_DT is the min duty cycle allowed for the radiator MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_RADIATOR_DT value (basically when the radiators need to go to max speed and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_RADIATOR_DT value (basically when radiators need to start cooling at them min duty cycle) The q factor as follows: \\(q = (MIN\\_RADIATOR\\_DT-(MIN\\_INVERTER\\_TEMP*m))\\) Given: Costant Value MAX_RADIATOR_DT 0.9 MIX_RADIATOR_DT 0.8 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Radiator Duty Cycle 0 -0.3 10 -0.1 20 0.1 30 0.3 40 0.5 50 0.7 60 0.9 Note Negative value are carried to zero via sw","title":"Radiators"},{"location":"fenice-bms-lv/Main%20functions/Cooling/#pumps","text":"The m factor as follows: \\(m = \\frac{(MAX\\_OPAMP\\_OUT-MIN\\_OPAMP\\_OUT)}{(MAX\\_INVERTER\\_TEMP-MIN\\_INVERTER\\_TEMP)}\\) Where: MAX_OPAMP_OUT is the max allowed output voltage given by the opamp wich feeds the pumps MAX_OPAMP_OUT is the min allowed output voltage given by the opamp wich feeds the pumps MAX_INVERTER_TEMP is the inverter temperature associated with the MAX_OPAMP_OUT value (basically when the pumps need to go to max power and cool as much as possible) MIN_INVERTER_TEMP is the inverter min temperature associated with MIN_OPAMP_OUT value (basically when pumps need to start cooling at them min power value) The q factor as follows: \\(q = MIN\\_OPAMP\\_OUT-(MIN\\_INVERTER\\_TEMP*m)\\) Given: Costant Value MAX_OPAMP_OUT 4.95 MIN_OPAMP_OUT 0 MAX_INVERTER_TEMP 60 MIN_INVERTER_TEMP 40 We can obtain: Inverter temperature \u00b0C Analog Pumps value 0 -9.9 10 -7.425 20 -4.95 30 -2.475 40 0 50 2.475 60 4.95 Note Negative value are carried to zero via sw","title":"Pumps"},{"location":"fenice-bms-lv/Main%20functions/Errors/","text":"Errors All errors are managed by a specific library written by: Simone Ruffini & Matteo Bonora . Here's a list of all possible errors the LV-BMSs can handle. Every error it's reported with its specific ID and TIMEOUT . ID Error name TIMEOUT 0 ERROR_CELL_UNDERVOLTAGE 400 1 ERROR_CELL_OVERVOLTAGE 400 2 ERROR_OPEN_WIRE 400 3 ERROR_CAN 500 4 ERROR_SPI 500 5 ERROR_OVER_CURRENT 400 6 ERROR_DCDC12_UNDER_TEMPERATURE 1000 7 ERROR_DCDC12_OVER_TEMPERATURE 1000 8 ERROR_DCDC24_UNDER_TEMPERATURE 1000 9 ERROR_DCDC24_OVER_TEMPERATURE 1000 10 ERROR_CELL_UNDER_TEMPERATURE 1000 11 ERROR_CELL_OVER_TEMPERATURE 1000 12 ERROR_RELAY SOFT 13 ERROR_LTC6810 500 14 ERROR_VOLTAGES_NOT_READY 500 15 ERROR_MCP23017 1000 16 ERROR_RADIATOR SOFT 17 ERROR_FAN SOFT 18 ERROR_PUMP SOFT 19 ERROR_ADC_INIT 1000 20 ERROR_DCDC12 SOFT 21 ERROR_DCDC24 SOFT Note SOFT means that the error won't be fatal in any case. Every error its represented as a node of a linked list, and it can hold multiple sub-errors, for example to handle the errors for the LV Accumulator // Declaration of the llist_node llist_node error_list_ref_low_voltages [ LV_CELLS_COUNT ] = { NULL }; // A single error inside the node can be set or reset using the offset An error can be set with: error_set ( ERROR_NAME , offset , starting_time ); and unset with: error_reset ( ERROR_NAME , offset ); If a set error reaches its TIMEOUT it become fatal and turn the LV-BMS into the error state .","title":"Errors"},{"location":"fenice-bms-lv/Main%20functions/Errors/#errors","text":"All errors are managed by a specific library written by: Simone Ruffini & Matteo Bonora . Here's a list of all possible errors the LV-BMSs can handle. Every error it's reported with its specific ID and TIMEOUT . ID Error name TIMEOUT 0 ERROR_CELL_UNDERVOLTAGE 400 1 ERROR_CELL_OVERVOLTAGE 400 2 ERROR_OPEN_WIRE 400 3 ERROR_CAN 500 4 ERROR_SPI 500 5 ERROR_OVER_CURRENT 400 6 ERROR_DCDC12_UNDER_TEMPERATURE 1000 7 ERROR_DCDC12_OVER_TEMPERATURE 1000 8 ERROR_DCDC24_UNDER_TEMPERATURE 1000 9 ERROR_DCDC24_OVER_TEMPERATURE 1000 10 ERROR_CELL_UNDER_TEMPERATURE 1000 11 ERROR_CELL_OVER_TEMPERATURE 1000 12 ERROR_RELAY SOFT 13 ERROR_LTC6810 500 14 ERROR_VOLTAGES_NOT_READY 500 15 ERROR_MCP23017 1000 16 ERROR_RADIATOR SOFT 17 ERROR_FAN SOFT 18 ERROR_PUMP SOFT 19 ERROR_ADC_INIT 1000 20 ERROR_DCDC12 SOFT 21 ERROR_DCDC24 SOFT Note SOFT means that the error won't be fatal in any case. Every error its represented as a node of a linked list, and it can hold multiple sub-errors, for example to handle the errors for the LV Accumulator // Declaration of the llist_node llist_node error_list_ref_low_voltages [ LV_CELLS_COUNT ] = { NULL }; // A single error inside the node can be set or reset using the offset An error can be set with: error_set ( ERROR_NAME , offset , starting_time ); and unset with: error_reset ( ERROR_NAME , offset ); If a set error reaches its TIMEOUT it become fatal and turn the LV-BMS into the error state .","title":"Errors"},{"location":"fenice-bms-lv/Main%20functions/Feedbacks%20signals/","text":"Feedbacks signals The IC MCP23017 is a GPIO Expander , which uses I2C bus to monitor the status of some feedbacks on the board. List of the feedbacks on board: FB_Main : indicate if LVMS is closed FB_12 : indicate if there are 12V on the DCDC12V output FB_PCBS : depends on FB_12 FB_Relay : indicate if the relay is closed or not FB_24 : indicate if there are 24V on the DCDC24V output FB_Inverters : depends on FB_24 FB_PUMPS : depends on FB_24 FB_SHUTDOWN : depends on FB_12 FB_RADIATORS : depends on FB_12 FB_FAN : depends on FB_12 Warning With the latest configuration of the board FB_Main is always 1 Note Latest configuration = BMS wiring inside its case Faq You can obtain a specific Feedback value using a specific functions declared in main.h Example //Check if there are 12V on board, needed to supply other boards bool feedback_state = FDBK_12V_PCBS_get_state ();","title":"Feedbacks signals"},{"location":"fenice-bms-lv/Main%20functions/Feedbacks%20signals/#feedbacks-signals","text":"The IC MCP23017 is a GPIO Expander , which uses I2C bus to monitor the status of some feedbacks on the board. List of the feedbacks on board: FB_Main : indicate if LVMS is closed FB_12 : indicate if there are 12V on the DCDC12V output FB_PCBS : depends on FB_12 FB_Relay : indicate if the relay is closed or not FB_24 : indicate if there are 24V on the DCDC24V output FB_Inverters : depends on FB_24 FB_PUMPS : depends on FB_24 FB_SHUTDOWN : depends on FB_12 FB_RADIATORS : depends on FB_12 FB_FAN : depends on FB_12 Warning With the latest configuration of the board FB_Main is always 1 Note Latest configuration = BMS wiring inside its case Faq You can obtain a specific Feedback value using a specific functions declared in main.h Example //Check if there are 12V on board, needed to supply other boards bool feedback_state = FDBK_12V_PCBS_get_state ();","title":"Feedbacks signals"},{"location":"fenice-bms-lv/Main%20functions/IOC%20file%20and%20pinout/","text":"IOC File and Pinout The .ioc file is the magic tool with the fw-devs can configure the pin functions, the peripherals parameters and the clock of the mcu. Here are the main pheriperals used in this project: Can Bus : to communicate with other devices on board UART : to communicate with the user in serial Baud Rate : 115200 Bit/s Word Length : 8 Bits Parity : None Stop Bits : 1 DAC : (Digital to Analog Converter) to control the pumps ADC : (Analog to Digital Converter) to read the temperature of the battery and the DCDCs, also used with the current sensing Current trasducer : HO-S_SP33-1106 (x1) ADC used : ADC1 Channel : CHANNEL 10 Sampling Time : 480 Cycles Temperature sensor : LM35 (x4) ADC used : ADC2 DCDC 12V Channel : CHANNEL 12 Sampling Time : 480 Cycles DCDC 24V Channel : CHANNEL 13 Sampling Time : 480 Cycles Battery side 1 Channel : CHANNEL 0 Sampling Time : 480 Cycles Battery side 2 Channel : CHANNEL 1 Sampling Time : 480 Cycles Timers : to manage time critical tasks TIM2 : used for Errors time tracking, Measurements, CAN messages Errors time tracking: Channel: TIM_CHANNEL_4 Mode: : Output compare no output Measurements : after the sensing phase the relative message it will be sent via CAN Cooling + LV_VERSION Channel: TIM_CHANNEL_1 Mode: : Output compare no output Timeout (ms): 1000 Current sensing + Inverter status Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 500 Voltage sensing + Temperature sensing Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 100 TIM3 : used to generate PWM signal for Right and Left radiators, and internal fan Left Radiator Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 24 kHz Right Radiator Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz Fan inside the BMS Case Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz TIM4 : used to check if OPEN WIRE occurs Open wire check Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 50 TIM5 : used to hardware trigger the ADC Open wire check Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 20 kHz TIM7 : used as sw interrupt to save ADC values via DMA Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 1 kHz TIM7 : used as pwm output for the buzzer Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 1 kHz","title":"IOC File and Pinout"},{"location":"fenice-bms-lv/Main%20functions/IOC%20file%20and%20pinout/#ioc-file-and-pinout","text":"The .ioc file is the magic tool with the fw-devs can configure the pin functions, the peripherals parameters and the clock of the mcu. Here are the main pheriperals used in this project: Can Bus : to communicate with other devices on board UART : to communicate with the user in serial Baud Rate : 115200 Bit/s Word Length : 8 Bits Parity : None Stop Bits : 1 DAC : (Digital to Analog Converter) to control the pumps ADC : (Analog to Digital Converter) to read the temperature of the battery and the DCDCs, also used with the current sensing Current trasducer : HO-S_SP33-1106 (x1) ADC used : ADC1 Channel : CHANNEL 10 Sampling Time : 480 Cycles Temperature sensor : LM35 (x4) ADC used : ADC2 DCDC 12V Channel : CHANNEL 12 Sampling Time : 480 Cycles DCDC 24V Channel : CHANNEL 13 Sampling Time : 480 Cycles Battery side 1 Channel : CHANNEL 0 Sampling Time : 480 Cycles Battery side 2 Channel : CHANNEL 1 Sampling Time : 480 Cycles Timers : to manage time critical tasks TIM2 : used for Errors time tracking, Measurements, CAN messages Errors time tracking: Channel: TIM_CHANNEL_4 Mode: : Output compare no output Measurements : after the sensing phase the relative message it will be sent via CAN Cooling + LV_VERSION Channel: TIM_CHANNEL_1 Mode: : Output compare no output Timeout (ms): 1000 Current sensing + Inverter status Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 500 Voltage sensing + Temperature sensing Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 100 TIM3 : used to generate PWM signal for Right and Left radiators, and internal fan Left Radiator Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 24 kHz Right Radiator Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz Fan inside the BMS Case Channel: TIM_CHANNEL_2 Mode: : PWM Generator CH2 Frequency: 24 kHz TIM4 : used to check if OPEN WIRE occurs Open wire check Channel: TIM_CHANNEL_2 Mode: : Output compare no output Timeout (ms): 50 TIM5 : used to hardware trigger the ADC Open wire check Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 20 kHz TIM7 : used as sw interrupt to save ADC values via DMA Channel: TIM_CHANNEL_1 Mode: : PWM Generator no output Frequency: 1 kHz TIM7 : used as pwm output for the buzzer Channel: TIM_CHANNEL_1 Mode: : PWM Generator CH1 Frequency: 1 kHz","title":"IOC File and Pinout"},{"location":"fenice-bms-lv/Main%20functions/State%20machine/","text":"State Machine Here you can find the firmware flowchart for the LV-BMS , don't be scared, there isn't a real state machine at all! The flowchart can be splitted into three stages: Warm up stage : Nothing in the car is already powered, the BMS is still initializing the peripherals and checking if there's a minimum amount of voltage from the battery to close the relay. Run stage : All the time critical tasks are executed Error stage : The system can still communicate via CLI and CAN Bus, however the relays is switched off and the car is not powered graph TD; subgraph Warm up stage A[Peripherals init] -->B[Accumulator total voltage measurement] B-->C{Measure attempt <br> <= <br> VOLT_MAX_ATTEMPTS} C--YES-->D{Total voltage measured <br> > <br> MIN_POWER_ON_VOLTAGE?} D--YES-->F[Close relay + Play buzzer] end C--NO-->E[Error state] D--NO-->B subgraph Run stage F-->F1[CLI Loop] F1-->F2[Do periodic measurements and send can messages] F2-->F2.1[Check feedback values] F2.1-->F3[Run cooling routine] F3-->F4{Errors or SCS?} F4--NO-->F1 F4--YES-->F5{Has error <br> reached its TIMEOUT?} F5--NO-->F1 end subgraph Error stage F5--YES-->E E-->E1[Open relay] E1-->E2[Loop CLI + Led Blink] E2-->E3[Do periodic measurements and send can messages] E3-->E2 end","title":"State Machine"},{"location":"fenice-bms-lv/Main%20functions/State%20machine/#state-machine","text":"Here you can find the firmware flowchart for the LV-BMS , don't be scared, there isn't a real state machine at all! The flowchart can be splitted into three stages: Warm up stage : Nothing in the car is already powered, the BMS is still initializing the peripherals and checking if there's a minimum amount of voltage from the battery to close the relay. Run stage : All the time critical tasks are executed Error stage : The system can still communicate via CLI and CAN Bus, however the relays is switched off and the car is not powered graph TD; subgraph Warm up stage A[Peripherals init] -->B[Accumulator total voltage measurement] B-->C{Measure attempt <br> <= <br> VOLT_MAX_ATTEMPTS} C--YES-->D{Total voltage measured <br> > <br> MIN_POWER_ON_VOLTAGE?} D--YES-->F[Close relay + Play buzzer] end C--NO-->E[Error state] D--NO-->B subgraph Run stage F-->F1[CLI Loop] F1-->F2[Do periodic measurements and send can messages] F2-->F2.1[Check feedback values] F2.1-->F3[Run cooling routine] F3-->F4{Errors or SCS?} F4--NO-->F1 F4--YES-->F5{Has error <br> reached its TIMEOUT?} F5--NO-->F1 end subgraph Error stage F5--YES-->E E-->E1[Open relay] E1-->E2[Loop CLI + Led Blink] E2-->E3[Do periodic measurements and send can messages] E3-->E2 end","title":"State Machine"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/","text":"Timing and CAN Messages Following the rules is mandatory for the LV-BMS and, to accomplish the required tasks, the system need to stick to a specific timing for each measurement or message sending. For this reason a specific timer with more compare threshold has been chosen (see TIM2 config) . For the 90% of the cases, when the timer is triggered to make a measure, it also send the relative payload via CAN. Intervals Here's the following periodic intervals Interval name Interval (ms) OPEN_WIRE_MEASURE 50 VOLT_MEASURE 100 CURRENT_AND_INVERTER_STATUS_MEASURE 500 TEMPERATURE_MEASURE 100 COOLING_STATUS 1000 LV_VERSION 1000 Flags setting When the measurement module is initialized the timer threshold are set and the flags are cleared. Help TIM2 is not the only timer which handles the measurements, in fact there's also TIM4 that it's dedicated to the OPEN WIRE check When an interrupts occurs a flag is set and the timer compare threshold is moved forward using for another period, in this way: // Set new threshold __HAL_TIM_SetCompare ( timer_handle , timer_channel , actual_counter + TIM_MS_TO_TICKS ( timer_handle , TRIGGERED_MEASURE_INTERVAL )); // Set the flag flags |= TRIGGERED_MEASURE_FLAG To understand if an event has occured a flag is set uint8_t flags ; // Like a bitset enum { MEAS_OPEN_WIRE = 1 , MEAS_VOLTS_AND_TEMPS_READ_FLAG = 2 , MEAS_COOLING_AND_LV_VERSION_READ_FLAG = 4 , MEAS_CURRENT_AND_INVERTERS_STATUS_READ_FLAG = 8 }; Flags check During the Running stage of the LV-BMS every flags checked with this basic logic: if ( flags & SELECTED_FLAG ){ //do stuffs ... //remove the flags flags &= ~ SELECTED_FLAGS ; } Example of a measure and can send if ( flags & MEAS_VOLTS_AND_TEMPS_READ_FLAG ) { // measure with the function sample and read if ( volt_sample_and_read () != VOLT_ERR ) { // if no errors are returned the data are sent via CAN can_primary_send ( primary_ID_LV_VOLTAGE ); can_primary_send ( primary_ID_LV_TOTAL_VOLTAGE ); } can_primary_send ( primary_ID_LV_TEMPERATURE ); flags &= ~ MEAS_VOLTS_AND_TEMPS_READ_FLAG ; }","title":"Timing and CAN Messages"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#timing-and-can-messages","text":"Following the rules is mandatory for the LV-BMS and, to accomplish the required tasks, the system need to stick to a specific timing for each measurement or message sending. For this reason a specific timer with more compare threshold has been chosen (see TIM2 config) . For the 90% of the cases, when the timer is triggered to make a measure, it also send the relative payload via CAN.","title":"Timing and CAN Messages"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#intervals","text":"Here's the following periodic intervals Interval name Interval (ms) OPEN_WIRE_MEASURE 50 VOLT_MEASURE 100 CURRENT_AND_INVERTER_STATUS_MEASURE 500 TEMPERATURE_MEASURE 100 COOLING_STATUS 1000 LV_VERSION 1000","title":"Intervals"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#flags-setting","text":"When the measurement module is initialized the timer threshold are set and the flags are cleared. Help TIM2 is not the only timer which handles the measurements, in fact there's also TIM4 that it's dedicated to the OPEN WIRE check When an interrupts occurs a flag is set and the timer compare threshold is moved forward using for another period, in this way: // Set new threshold __HAL_TIM_SetCompare ( timer_handle , timer_channel , actual_counter + TIM_MS_TO_TICKS ( timer_handle , TRIGGERED_MEASURE_INTERVAL )); // Set the flag flags |= TRIGGERED_MEASURE_FLAG To understand if an event has occured a flag is set uint8_t flags ; // Like a bitset enum { MEAS_OPEN_WIRE = 1 , MEAS_VOLTS_AND_TEMPS_READ_FLAG = 2 , MEAS_COOLING_AND_LV_VERSION_READ_FLAG = 4 , MEAS_CURRENT_AND_INVERTERS_STATUS_READ_FLAG = 8 };","title":"Flags setting"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#flags-check","text":"During the Running stage of the LV-BMS every flags checked with this basic logic: if ( flags & SELECTED_FLAG ){ //do stuffs ... //remove the flags flags &= ~ SELECTED_FLAGS ; }","title":"Flags check"},{"location":"fenice-bms-lv/Main%20functions/Timing%20and%20Can%20messages/#example-of-a-measure-and-can-send","text":"if ( flags & MEAS_VOLTS_AND_TEMPS_READ_FLAG ) { // measure with the function sample and read if ( volt_sample_and_read () != VOLT_ERR ) { // if no errors are returned the data are sent via CAN can_primary_send ( primary_ID_LV_VOLTAGE ); can_primary_send ( primary_ID_LV_TOTAL_VOLTAGE ); } can_primary_send ( primary_ID_LV_TEMPERATURE ); flags &= ~ MEAS_VOLTS_AND_TEMPS_READ_FLAG ; }","title":"Example of a measure and can send"},{"location":"fenice-das-sw/","text":"Data Acquisition System The DAS codedbase in organized in modules so that every functionality can be easily located. Each module is indentifued by a three- or four-letter prefix that is prepended to every exported memeber (variable or function) so that no namespace collisions occur. Private members use this prefix as well but in turn prefixed with an underscore. The modules are the following: - Brakelight - Buzzer - CAN Bus - Encoders - Finite State Machine - Inverters - Pedals - Traction Control - Tractive System Brakelight Prefix: BKL Description: operate the three PWM channels connected to the brake light In-depth documentation: bkl.md Buzzer Prefix: BUZ Description: Activate and deactivate the buzzer, with sync or async calls In-depth documentation: buz.md CAN Prefix: CAN, CANMSG Description: In-depth documentation: Encoders Prefix: ENC Description: In-depth documentation: FSM Prefix: VFSM Description: In-depth documentation: Inverters Prefix: INV Description: In-depth documentation: Pedals Prefix: PED Description: In-depth documentation: Traction Control Prefix: CTRL Description: In-depth documentation: Tractive System Prefix: TSs Description: In-depth documentation:","title":"Introduction"},{"location":"fenice-das-sw/#data-acquisition-system","text":"The DAS codedbase in organized in modules so that every functionality can be easily located. Each module is indentifued by a three- or four-letter prefix that is prepended to every exported memeber (variable or function) so that no namespace collisions occur. Private members use this prefix as well but in turn prefixed with an underscore. The modules are the following: - Brakelight - Buzzer - CAN Bus - Encoders - Finite State Machine - Inverters - Pedals - Traction Control - Tractive System","title":"Data Acquisition System"},{"location":"fenice-das-sw/#brakelight","text":"Prefix: BKL Description: operate the three PWM channels connected to the brake light In-depth documentation: bkl.md","title":"Brakelight"},{"location":"fenice-das-sw/#buzzer","text":"Prefix: BUZ Description: Activate and deactivate the buzzer, with sync or async calls In-depth documentation: buz.md","title":"Buzzer"},{"location":"fenice-das-sw/#can","text":"Prefix: CAN, CANMSG Description: In-depth documentation:","title":"CAN"},{"location":"fenice-das-sw/#encoders","text":"Prefix: ENC Description: In-depth documentation:","title":"Encoders"},{"location":"fenice-das-sw/#fsm","text":"Prefix: VFSM Description: In-depth documentation:","title":"FSM"},{"location":"fenice-das-sw/#inverters","text":"Prefix: INV Description: In-depth documentation:","title":"Inverters"},{"location":"fenice-das-sw/#pedals","text":"Prefix: PED Description: In-depth documentation:","title":"Pedals"},{"location":"fenice-das-sw/#traction-control","text":"Prefix: CTRL Description: In-depth documentation:","title":"Traction Control"},{"location":"fenice-das-sw/#tractive-system","text":"Prefix: TSs Description: In-depth documentation:","title":"Tractive System"},{"location":"fenice-das-sw/bkl/","text":"Brakelight This module exports two functions and one enum: void BKL_light_show_step() Update, at each call, the status of a light sequence that alternates channels and PWM duty-cycles to test the brakelight void BKL_toggle(BKL_StateTypeDef state) Set the state of the brakelight to one of the options provied in the enumeration. typdef enum { ... } BKL_StateTypeDef The available states of the brakelight: BKL_OFF : Off BKL_LVL_1 : Low intensity BKL_LVL_2 : Medium intensity BKL_LVL_3 : Maximum intensity","title":"Brakelight"},{"location":"fenice-das-sw/bkl/#brakelight","text":"This module exports two functions and one enum:","title":"Brakelight"},{"location":"fenice-das-sw/bkl/#void-bkl_light_show_step","text":"Update, at each call, the status of a light sequence that alternates channels and PWM duty-cycles to test the brakelight","title":"void BKL_light_show_step()"},{"location":"fenice-das-sw/bkl/#void-bkl_togglebkl_statetypedef-state","text":"Set the state of the brakelight to one of the options provied in the enumeration.","title":"void BKL_toggle(BKL_StateTypeDef state)"},{"location":"fenice-das-sw/bkl/#typdef-enum-bkl_statetypedef","text":"The available states of the brakelight: BKL_OFF : Off BKL_LVL_1 : Low intensity BKL_LVL_2 : Medium intensity BKL_LVL_3 : Maximum intensity","title":"typdef enum { ... } BKL_StateTypeDef"},{"location":"fenice-das-sw/buz/","text":"Buzzer This module exports a transparent interface to start and stop sync and async beeps from a buzzer. void BUZ_beep_ms_sync(uint16_t ms) Activate the buzzer and return to the caller after ms milliseconds. void BUZ_beep_ms_async(uint16_t ms) Activate the buzzer and return to the caller. It will be deactivated after ms milliseconds when the function below will be called the next time. void BUZ_timer_callback() If the buzzer is active, check if the required time has passed and stop it.","title":"Buzzer"},{"location":"fenice-das-sw/buz/#buzzer","text":"This module exports a transparent interface to start and stop sync and async beeps from a buzzer.","title":"Buzzer"},{"location":"fenice-das-sw/buz/#void-buz_beep_ms_syncuint16_t-ms","text":"Activate the buzzer and return to the caller after ms milliseconds.","title":"void BUZ_beep_ms_sync(uint16_t ms)"},{"location":"fenice-das-sw/buz/#void-buz_beep_ms_asyncuint16_t-ms","text":"Activate the buzzer and return to the caller. It will be deactivated after ms milliseconds when the function below will be called the next time.","title":"void BUZ_beep_ms_async(uint16_t ms)"},{"location":"fenice-das-sw/buz/#void-buz_timer_callback","text":"If the buzzer is active, check if the required time has passed and stop it.","title":"void BUZ_timer_callback()"},{"location":"fenice-ecu/","text":"Electronic Control Unit Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Introduction"},{"location":"fenice-ecu/#electronic-control-unit","text":"Fenice's ECU controls the global state of the vehicle and manages its transitions between states. For example, when the driver requests the car to enter the RUN state, the ECU will execute all needed operations and will prepare the vehicle to meet all needed constraints in order to safely move. Although its main task is rather simple, this component is actually composed of many modules. The first reason is that this apparently small state machine conceals quite a lot of abstraction, therefore needing a certain quantity of code in order to reach down to the low level of a micro-controller interface. The second reason follows from the first, meaning that all this code, in order to remain maintainable and reliable in time, needs a proper level of modularization and separation.","title":"Electronic Control Unit"},{"location":"fenice-ecu/can/","text":"CAN CubeMX Connectivity CAN: Activated Bit timing parameters (http://www.bittiming.can-wiki.info/) Prescaler TQ1 TQ2 NVIC: impisa tuto Generate Code Activate Notifications Register Callbacks Activate Filters HAL_CAN_Start // Add MCP oscilloscope debugging","title":"Can"},{"location":"fenice-ecu/can/#can","text":"","title":"CAN"},{"location":"fenice-ecu/can/#cubemx","text":"Connectivity CAN: Activated Bit timing parameters (http://www.bittiming.can-wiki.info/) Prescaler TQ1 TQ2 NVIC: impisa tuto Generate","title":"CubeMX"},{"location":"fenice-ecu/can/#code","text":"Activate Notifications Register Callbacks Activate Filters HAL_CAN_Start // Add MCP oscilloscope debugging","title":"Code"},{"location":"fenice-ecu/fsm/","text":"Finite State Machine Warning This document is no way definitive or contains reliable information States: Init The microcontroller is initializing its state and peripherals. Idle The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state. Precharge Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state. Inv. Updates Activation Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state. Inv. Drive Activation Enable the inverters (Drive Mode) and upon confirmation enter the run state. Run Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state. Inv. Drive Deactivation Disable the inverters and upon confirmation enter the inv_updates_deactivation state. Inv. Updates Deactivation Stop the inverters status reports and enter the discharge state. Discharge Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#finite-state-machine","text":"Warning This document is no way definitive or contains reliable information","title":"Finite State Machine"},{"location":"fenice-ecu/fsm/#states","text":"","title":"States:"},{"location":"fenice-ecu/fsm/#init","text":"The microcontroller is initializing its state and peripherals.","title":"Init"},{"location":"fenice-ecu/fsm/#idle","text":"The ECU is ready to operate and receive inputs. Upon a TS_ON request, enter the precharge state.","title":"Idle"},{"location":"fenice-ecu/fsm/#precharge","text":"Send the BMS-HV a TS_ON message and wait for its precharge to complete, then enter the inv_updates_activation state.","title":"Precharge"},{"location":"fenice-ecu/fsm/#inv-updates-activation","text":"Ask the inverters to start reporting the contents of their status registers every 100ms. When the request is fulfilled, enter the inv_drive_activation state.","title":"Inv. Updates Activation"},{"location":"fenice-ecu/fsm/#inv-drive-activation","text":"Enable the inverters (Drive Mode) and upon confirmation enter the run state.","title":"Inv. Drive Activation"},{"location":"fenice-ecu/fsm/#run","text":"Read pedal values from the PCU and forward them to the Control Unit and/or the inverters. Upon a TS_OFF request, enter the inv_drive_deactivation state.","title":"Run"},{"location":"fenice-ecu/fsm/#inv-drive-deactivation","text":"Disable the inverters and upon confirmation enter the inv_updates_deactivation state.","title":"Inv. Drive Deactivation"},{"location":"fenice-ecu/fsm/#inv-updates-deactivation","text":"Stop the inverters status reports and enter the discharge state.","title":"Inv. Updates Deactivation"},{"location":"fenice-ecu/fsm/#discharge","text":"Send the BMS-HV a TS_OFF request and, upon fulfillment, enter the idle state.","title":"Discharge"},{"location":"fenice-ecu/modules/","text":"Modules UART Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422 Timers List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output Buzzer As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line. CAN Fenice's internal networks operate on two CAN buses. Networks Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8 Bit Timing Parameters APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1 Messages For the list and definition of all CAN messages please refer to the can-cicd documentation . SPI The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below. IMU This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes Sensor Configuration In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ... IRTS Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...) Inverters The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors Status Register Contents Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected Current-Torque Curve and Power Limiting Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768 PCU This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received Tractive System The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...). Traction Control Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page. Encoders Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering. Wheels Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section . Steering ...","title":"Modules"},{"location":"fenice-ecu/modules/#modules","text":"","title":"Modules"},{"location":"fenice-ecu/modules/#uart","text":"Four devices make use of serial communication: a textual UART for debugging messages, two wheel encoders, and one steering encoder. Among these, however, only the debugging UART is directly interfaced with the STM serial controller: Interface TX Pin RX Pin Baud Rate Description UART4 PA12 PA13 115200 Debugging messages The serial signal from the wheel encoders instead, is decoded by transceivers on the DAS board that, in turn, feed two timer channels each that operate in Encoder Mode . Further details on the interfacing with timers are given in the Timer section , while information on their decoding is available in the Encoders section . Device Protocol Wheel Encoders ( LM13ICD40AB10F00 ) RS422 Steer Encoder ( RM44SC0012B10F2F10 ) RS422","title":"UART"},{"location":"fenice-ecu/modules/#timers","text":"List of STM timers employed: Timer Mode Pins Description TIM2 Combined Channels: Encoder Mode PA15 (CH1), PB3 (CH2) Left wheel encoder TIM5 Combined Channels: Encoder Mode PA0 (CH1), PA1 (CH2) Right wheel encoder TIM10 Channel1: PWM Generation CH1 PB8 Buzzer PWM output","title":"Timers"},{"location":"fenice-ecu/modules/#buzzer","text":"As required by the rulebook, the ECU must beep a buzzer for at least (?) ... The buzzer is driven by a MOSFET operated via the PWM output generated by the TIM10 timer on pin PB8, and powered by the 12V line.","title":"Buzzer"},{"location":"fenice-ecu/modules/#can","text":"Fenice's internal networks operate on two CAN buses.","title":"CAN"},{"location":"fenice-ecu/modules/#networks","text":"Network Interface CAN_TX Pin CAN_RX Pin Primary CAN1 PD1 PD0 Secondary CAN3 PB4 PA8","title":"Networks"},{"location":"fenice-ecu/modules/#bit-timing-parameters","text":"APB1 Peripheral Clock (PCLK1): 54 MHz Prescaler: 3 Time Quantum is therefore 55.555 ns Time Quanta in Bit Segment 1: 12 Time Quanta in Bit Segment 2: 5 Time for one bit is therefore 999.99 ns Baud rate is therefore 1000000 bps ( 1 Mbit/s ) ReSynchronization Jump Width: 1","title":"Bit Timing Parameters"},{"location":"fenice-ecu/modules/#messages","text":"For the list and definition of all CAN messages please refer to the can-cicd documentation .","title":"Messages"},{"location":"fenice-ecu/modules/#spi","text":"The SPI interface is used to communicate with the Traction Control Unit and exchange information on vehicle state and motor torque. Since the TCU runs on a Raspberry Pi which is, by design, only capable of operating as a Master node, the ECU acts as the Slave node. Interface CLK Pin ... ... For more information on how and what information is exchanged, please refer to the Traction Control section below.","title":"SPI"},{"location":"fenice-ecu/modules/#imu","text":"This module records the acceleration data coming from the Inertial Measurement Unit (IMU) sensor over the CAN network. Namely, it receives: - Linear acceleration on the three directions - Gyroscopic acceleration on the three axes","title":"IMU"},{"location":"fenice-ecu/modules/#sensor-configuration","text":"In order to work properly, the sensor needs to be configured with the following parameters: - Sampling frequency: ? - ...","title":"Sensor Configuration"},{"location":"fenice-ecu/modules/#irts","text":"Four Infra-Red Temperature Sensors (IRTSs) are pointed toward the tires and measure their temperature gradient using 8 (?) channels each (...)","title":"IRTS"},{"location":"fenice-ecu/modules/#inverters","text":"The Inverters and the ECU communicate over the CAN network and exchange the following information: - The ECU periodically (at which freq. ?) sends two torque values to be applied to the motors, one for the left side and one for the right side - The inverters periodically (every 100ms) report the contents of their status register (more details below) - The inverters periodically (every 100ms) report the output voltage at which they are driving the motors","title":"Inverters"},{"location":"fenice-ecu/modules/#status-register-contents","text":"Bit Symbol Description 0 Ena Drive Enable 1 RcR0 Speed limit to zero 2 Lim+ Limited switch + tripped 3 Lim- Limited switch - tripped 4 OK Drive okay 5 Icns Current is limited to the continuous current level 6 T-Nlim Speed limit torque mode active 7 P-N Position control active 8 N-I Speed control active 9 <N0 Actual speed is less than 0.1% 10 Rsw Reference switch tripped 11 Cal0 Calibration move active 12 Cal Calibration move completed 13 Tol Position within tolerance window 14 Rdy Drive ready (BTB/RDY contact closed) 15 Brk0 Unexcited brake with motor active 16 SignMag Speed internally inverted 17 Nclip Speed limiting enabled (N-Lim < 90%) 18 Nclip+ Speed limiting (+) via input switch enabled 19 Ncip- Speed limiting (-) via input switch enabled 20 Ird-Dig Current limiting via input switch enabled 21 Iuse-rchd Actual current limit reached 22 Ird-N Current derating to cont. current via speed limit enabled 23 Ird-TI Current derating to cont. current due to igbt temp. enabled 24 Ird-TIR Current derating to cont. current due to igbt temp. active 25 >10Hz Current derating to cont. current at rotation freq. < 10 Hz active 26 Ird-TM Current derating to cont. current due to motor temp. active 27 Ird-Ana Current derating due to analog input (if <= 90%) possible 28 Iwcns Current peak value warning 29 RFEpulse Pulsed RFE - input monitoring active 30 M+d vacant 31 HndWhl Hand-wheel function selected","title":"Status Register Contents"},{"location":"fenice-ecu/modules/#current-torque-curve-and-power-limiting","text":"Note Controlling the inverters by torque or current is equivalent Since, for a given current, power absorption of the motors is proportional to their rotational speed, and given that inverters are controlled in torque/current mode, care must be taken not to request more than the allowed limit of 80 KWh. More details on the matter are available in this report: Essentially, requesting the maximum available current of 200A per motor when the angular velocity is above 4000 RPM causes the power to exceed the allowed limit. To overcome this issue, the following equation must then be followed to obtain the correct torque limit at each rotational speed: \\[ C_{mot\\_max} = \\begin{cases} C_{max} & \\text{if } \\omega_{mot} < \\omega_{limit} \\\\ \\frac{358098.6}{\\omega_{mot}} & \\text{if } \\omega_{mot} \\geq \\omega_{limit} \\end{cases} \\] At this point, the current value must be converted into a 16-bits integer to be sent to the inverters, which is a percent value of the characteristic maximum current of the device, equal to 423A (e.g., 50% = +32768 = 212.5A). Consequently, the maximum current of 200A (corresponding to the 47.3% of the maximum peak) will be represented as 15493. Some clarifying examples follow: Current Percent int16 -423 A -100% -32768 0 A 0% 0 200 A +47.2% +15493 423 A +100% +32768","title":"Current-Torque Curve and Power Limiting"},{"location":"fenice-ecu/modules/#pcu","text":"This module controls all communication (via CAN-Bus) between the ECU and the Pedal Control Unit (PCU). More specifically: - ADC brake and accelerator values are read and scaled from 0 to 100 - Errors and Warnings are checked (e.g. implausibility) - Calibration values are read/written from/to the EEPROM and sent/received","title":"PCU"},{"location":"fenice-ecu/modules/#tractive-system","text":"The TC code handles the generation and delivery of messages concerning the status of the BMS-HV (PRECHARGE, TS-ON, TS-OFF, ...).","title":"Tractive System"},{"location":"fenice-ecu/modules/#traction-control","text":"Since the actual software for controlling the traction of the vehicle runs on a separate device (for reliability purposes), the ECU and the Traction Control Unit (TCU) need to constantly exchange a number of values. Parameter Name Direction Description Brake ECU -> TCU How much the brake pedal is pressed ... Further technical details on how this data is exchanged over SPI can be found at the TCU Protocol page.","title":"Traction Control"},{"location":"fenice-ecu/modules/#encoders","text":"Magnetic rotative encoders are used to read angular speed from wheels and absolute position from steering.","title":"Encoders"},{"location":"fenice-ecu/modules/#wheels","text":"Wheel encoders are composed of a magnetic ring and a read head. Following, is the data-sheet of the read head where its characteristics are described: Decoding the part number ( LM13ICD40AB10F00 ) and referencing the various tables gives the following key points: Most importantly, we must note that at maximum measurable speed (18.67 m/s, on the ring), each timer will be fed with two 8 MHz signals, leading to 4 million increments/decrements per second. TIM2 and TIM5 have been chosen specifically for their 32-bits counter registers (in contrast with other timers' 16-bits counters) so that they can receive up to 4'294'967'296 pulses before overflowing (instead of 65536 for 16 bits). Consequently, while 16 bit timers would need to be read and reset at most every 16 milliseconds, TIM2 and TIM5 could allow for correct counting for over 17 minutes. Nonetheless, for efficient decoding and to avoid periodic overflows, timer counters should be reset to 0 after every read, which as said, is now free to happen at lower frequencies than every 16 milliseconds, if needed. For information on timer configuration on the STM, see the Timers section .","title":"Wheels"},{"location":"fenice-ecu/modules/#steering","text":"...","title":"Steering"},{"location":"fenice-steeringwheel/","text":"Steering Wheel Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/#steering-wheel","text":"Welcome to the Fenice Steering Wheel documentation. Fenice Steering Wheel is a modular Qt application that interacts with the rest of the vehicle and displays useful information to the team and the pilot during preparation or race. In production the software is deployed to a Raspberry Pi 3b+ into a custom PCB that allows simple communications with all the I/O of the device. During development the software can be tested on any x86 machine that supports Qt natively. Most of the custom I/O is abstracted so complex interaction can still be tested.","title":"Steering Wheel"},{"location":"fenice-steeringwheel/development/qt/","text":"Building Qt for the Raspberry Pi This guide is an edited version of the original by abhiTronix . Prerequites A. Hardware Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module B. Software Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested) C. Others Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions. Setup the Target Machine 1. Start from Scratch (Optional) Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it. 1.1. Download Softwares & Prepare the SD card Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked. 1.2 Set up Network Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way 2. Set up SSH If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi. 3. Open Terminal From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it. 4. Enable GL (FAKE KMS) To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so. 5. Enable Development Sources You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit. 6. Update the system Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade 7. Enable rsync with elevated rights Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed. 8. Install the important Development Packages Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev 9. Additional packages (Optional) You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev 10. Create directory for QT Deployment Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup. Setup the Host Machine Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network. 1. Update the Host Machine First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet 2. Setting up the directory structure You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory. 3. Download & Extract QT Source A. Download Binary Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory. B. Extract Binary Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz 4. Patching QT Source We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf 5. Download & Extract the Precompiled Cross-Compiler Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again. A. Copy Binary URL Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested. B. Download Binary After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz C. Extract Binary Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz 6. Sync Raspberry Pi sysroot (Most Important) First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues. 7. Fix symbolic links The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot 8. Configure QT Build Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete. 8.1 Check Configure Output Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl 8.2 Check if EGLFS enabled QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section 9. Build QT Source Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time! 10. Install QT Source Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories 11. Deploy QT to Raspberry Pi First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local Final Step for Target Machine Update linker on Raspberry Pi Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#building-qt-for-the-raspberry-pi","text":"This guide is an edited version of the original by abhiTronix .","title":"Building Qt for the Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#prerequites","text":"","title":"Prerequites"},{"location":"fenice-steeringwheel/development/qt/#a-hardware","text":"Host: Any x86 / x86_64 AMD / Intel machine Target: Raspberry Pi any variant / module","title":"A. Hardware"},{"location":"fenice-steeringwheel/development/qt/#b-software","text":"Host: Any Linux machine (Ubuntu 20.04 Tested) Target: Any Raspberry Pi Linux 32-bit OS (Raspbian Buster Tested)","title":"B. Software"},{"location":"fenice-steeringwheel/development/qt/#c-others","text":"Storage and Time Requirements: The build directory takes around \\~10GB space and about 2-5 hours to complete (based on dependencies & Host Machine Specifications) . Networking: Your Target Machine (Raspberry Pi) and Host Machine (where you cross-compiling) both must have internet access, and must be on same network to follow these instructions.","title":"C. Others"},{"location":"fenice-steeringwheel/development/qt/#setup-the-target-machine","text":"","title":"Setup the Target Machine"},{"location":"fenice-steeringwheel/development/qt/#1-start-from-scratch-optional","text":"Important: If you just brought a new Raspberry Pi or wanted to start from scratch just follow along. Otherwise, if you already has your Raspberry Pi setup, running, and Network Ready, then just skip to step 2 . Note: This section assume you have atleast 10GB SDcard for installing Raspbian Buster OS and a Laptop/PC for uploading it.","title":"1. Start from Scratch (Optional)"},{"location":"fenice-steeringwheel/development/qt/#11-download-softwares-prepare-the-sd-card","text":"Download the latest version of Raspbian (Buster) from here on your laptop/pc. You will be needing an image writer to write the downloaded OS into the SD card (micro SD card in our case) . So download the open-source \u201cwin32 disk imager\u201d from here , OR you can also use Balena Etcher instead. Insert the SD card into the laptop/pc and run the image writer. Once open, browse and select the downloaded Raspbian image file. Select the correct device, that is the drive representing the SD card. Note: If the drive (or device) selected is different from the SD card then the other selected drive will become corrupted. SO BE CAREFUL! Once the write is complete, eject the SD card and insert it into the Raspberry Pi and turn it on. It should start booting up. Please remember that after booting the Pi, there might be situations when the user credentials like the \u201cusername\u201d and password will be asked. Raspberry Pi comes with a default username pi and password raspberry and so use it whenever it is being asked.","title":"1.1. Download Softwares &amp; Prepare the SD card"},{"location":"fenice-steeringwheel/development/qt/#12-set-up-network","text":"Now the you have your Raspberry Pi up and Running, its time to connect it your network with one of following ways: If you have Monitor . If you don\u2019t have Monitor Any other way","title":"1.2 Set up Network"},{"location":"fenice-steeringwheel/development/qt/#2-set-up-ssh","text":"If you have Monitor: On the Raspberry Pi terminal, type: sudo raspi-config and menu should pop up on your terminal. To enable SSH, go to: Interfacing Options -> SSH -> Yes , and Click OK to enable it. Choose Finish finally and exit. If you don\u2019t have Monitor: After setting up the network, if you don\u2019t have monitor or you operating it remotely. Then, enable SSH by just taking out your SD card, and hook it your computer, and simply create an empty file called ssh in the /boot/parition path inside SD card. Now insert back SD card into the Raspberry Pi.","title":"2. Set up SSH"},{"location":"fenice-steeringwheel/development/qt/#3-open-terminal","text":"From another Laptop/PC using SSH: To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace 192.160.1.47 with the IP address of the Raspberry Pi. Use Ctrl + Shift + V to paste in the terminal. ssh pi@192.168.1.47 It will ask for password, and if not changed, it is default ( raspberry ), and so use it whenever it is being asked. Note: It is possible to configure your Raspberry Pi to allow access from another computer without needing to provide a password each time you connect. For more details, see here . On Raspberry Pi directly with a Monitor: Just search \u201cTerminal\u201d and click on it.","title":"3. Open Terminal"},{"location":"fenice-steeringwheel/development/qt/#4-enable-gl-fake-kms","text":"To enable Fake KMS, type sudo raspi-config on your terminal to open a menu, then go to: Advanced Options -> A8 GL Driver -> G2 GL (Fake KMS) That should enable KMS. Choose Finish finally and exit. Note: If you are using a minimal build, you may be prompted to download some updates before this option becomes available. If asked, do so.","title":"4. Enable GL (FAKE KMS)"},{"location":"fenice-steeringwheel/development/qt/#5-enable-development-sources","text":"You need to edit your sources list to enable development sources. To do this, enter the following command into pi terminal: sudo nano /etc/apt/sources.list In the nano text editor, uncomment the following line by removing the # character from following line: deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi When done, press Ctrl+O and then ENTER to quit.","title":"5. Enable Development Sources"},{"location":"fenice-steeringwheel/development/qt/#6-update-the-system","text":"Run the following commands in terminal to update the system sudo apt update sudo apt dist-upgrade","title":"6. Update the system"},{"location":"fenice-steeringwheel/development/qt/#7-enable-rsync-with-elevated-rights","text":"Later in this guide, we will be using the rsync command to sync files between the Host PC/Laptop and the Raspberry Pi. For some of these files, root rights (i.e. sudo) is required internally. You can do this with a single terminal command as follows: echo \" $USER ALL=NOPASSWD: $( which rsync ) \" | sudo tee --append /etc/sudoers That\u2019s it. Now rsync should be setup to run with sudo if needed.","title":"7. Enable rsync with elevated rights"},{"location":"fenice-steeringwheel/development/qt/#8-install-the-important-development-packages","text":"Run the following commands in Raspberry Pi terminal to install the required packages: sudo apt install build-essential cmake unzip pkg-config gfortran sudo apt build-dep qt5-qmake libqt5gui5 libqt5webengine-data libqt5webkit5 libudev-dev libinput-dev libts-dev libxcb-xinerama0-dev libxcb-xinerama0 gdbserver sudo apt install libxcb-randr0-dev libxcb-xtest0-dev libxcb-shape0-dev libxcb-xkb-dev","title":"8. Install the important Development Packages"},{"location":"fenice-steeringwheel/development/qt/#9-additional-packages-optional","text":"You can install these packages if you want additional multimedia and bluetooth capability with your QT binaries: # additional (multimedia) packages sudo apt install libjpeg-dev libpng-dev libtiff-dev sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt install libxvidcore-dev libx264-dev # audio packages sudo apt install libopenal-data libsndio7.0 libopenal1 libopenal-dev pulseaudio # bluetooth packages sudo apt install bluez-tools sudo apt install libbluetooth-dev # gstreamer (multimedia) packages sudo apt install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa gstreamer1.0-gl gstreamer1.0-gtk3 gstreamer1.0-qt5 gstreamer1.0-pulseaudio sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev","title":"9. Additional packages (Optional)"},{"location":"fenice-steeringwheel/development/qt/#10-create-directory-for-qt-deployment","text":"Now we create directories where the built QT Binaries will be deployed to your the Rasberry Pi, with following commands: sudo mkdir /usr/local/qt5.15 sudo chown -R pi:pi /usr/local/qt5.15 Also don\u2019t forget to setup Important Symlinks as follows: (Important) sudo ln -sf -r /usr/include/arm-linux-gnueabihf/asm /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/gnu /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/bits /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/sys /usr/include sudo ln -sf -r /usr/include/arm-linux-gnueabihf/openssl /usr/include sudo ln -sf /usr/lib/arm-linux-gnueabihf/crtn.o /usr/lib/crtn.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crt1.o /usr/lib/crt1.o sudo ln -sf /usr/lib/arm-linux-gnueabihf/crti.o /usr/lib/crti.o That\u2019s it for Raspberry Pi setup.","title":"10. Create directory for QT Deployment"},{"location":"fenice-steeringwheel/development/qt/#setup-the-host-machine","text":"Now Raspberry Pi Side all setup, Let\u2019s focus on commands for our Host Machine, i.e. PC/Laptop, where you going to cross-compile the QT Binaries for your Raspberry Pi. Important: Make sure your Raspberry Pi and this Host machine (where you cross-compiling) MUST be on the SAME Network.","title":"Setup the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#1-update-the-host-machine","text":"First of all, Run the following commands to update your system and install important dependancies: sudo apt update sudo apt dist-upgrade sudo apt install build-essential cmake unzip gfortran sudo apt install gcc git bison python gperf pkg-config gdb-multiarch wget sudo apt-get -y install gcc g++ gperf flex texinfo gawk bison openssl pigz libncurses-dev autoconf automake tar figlet","title":"1. Update the Host Machine"},{"location":"fenice-steeringwheel/development/qt/#2-setting-up-the-directory-structure","text":"You can use these following commands to create \u201crpi-qt\u201d to use as workspace for building QT Binaries: sudo mkdir ~/rpi-qt sudo mkdir ~/rpi-qt/build sudo mkdir ~/rpi-qt/tools sudo mkdir ~/rpi-qt/sysroot sudo mkdir ~/rpi-qt/sysroot/usr sudo mkdir ~/rpi-qt/sysroot/opt sudo chown -R 1000 :1000 ~/rpi-qt cd ~/rpi-qt Note: Ensure the last command should have changed your current directory to ~/rpi-qt . If not, run the last line again to make sure you are inside it, as the next steps assume you\u2019re running your commands from this directory.","title":"2. Setting up the directory structure"},{"location":"fenice-steeringwheel/development/qt/#3-download-extract-qt-source","text":"","title":"3. Download &amp; Extract QT Source"},{"location":"fenice-steeringwheel/development/qt/#a-download-binary","text":"Now, we can download the Latest source files for QT LTS (i.e. v5.15.2 ) by running following Terminal command to download the source files: sudo wget http://download.qt.io/archive/qt/5.15/5.15.2/single/qt-everywhere-src-5.15.2.tar.xz Note: You can also manually download file through browser, and place it in the ~/rpi-qt directory.","title":"A. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#b-extract-binary","text":"Extract the downloaded tar file with the following command: sudo tar xfv qt-everywhere-src-5.15.2.tar.xz","title":"B. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#4-patching-qt-source","text":"We need to slightly modify the a mkspec file within the source files to allow us to use our cross compiler. We will copy an existing directory within the source files, and modify the name of the directory and the contents of the qmake.conf file within that directory to follow the name of our compiler. To do this, run the following two command: cp -R qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabi-g++ qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++ sed -i -e 's/arm-linux-gnueabi-/arm-linux-gnueabihf-/g' qt-everywhere-src-5.15.2/qtbase/mkspecs/linux-arm-gnueabihf-g++/qmake.conf","title":"4. Patching QT Source"},{"location":"fenice-steeringwheel/development/qt/#5-download-extract-the-precompiled-cross-compiler","text":"Let\u2019s first change into tools directory for downloading our Precompiled Cross-compiler with the following command: cd ~/rpi-qt/tools Note: Ensure the last command should have changed your current directory to ~/rpi-qt/tools now. If not, run it again.","title":"5. Download &amp; Extract the Precompiled Cross-Compiler"},{"location":"fenice-steeringwheel/development/qt/#a-copy-binary-url","text":"Copy URL from one of following Precompiled Compressed Base-Toolchain (for maximum compatability) based on your Raspberry Pi Variant and OS you installed on it, from below: Raspberry Pi Board Stretch (32 bit) Buster (32 bit) Zero/W/WH & 1 Model A/B/A+/B+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-6.3.0-pi_0-1.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%201%2C%20Zero/cross-gcc-8.3.0-pi_0-1.tar.gz 2 & 3 Model A/B https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-6.3.0-pi_2-3.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz 3 & 4 Model A+/B+ & Compute 3/3-lite/3+ https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Stretch/GCC%206.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-6.3.0-pi_3%2B.tar.gz https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%203A%2B%2C%203B%2B%2C%204/cross-gcc-8.3.0-pi_3%2B.tar.gz Note: You can also use the latest cross-compiler binaries instead. But they are not tested.","title":"A. Copy Binary URL"},{"location":"fenice-steeringwheel/development/qt/#b-download-binary","text":"After that, paste your copied URL and run the following command to download the Cross-compiler: wget <Copied Binary URL goes here> #for e.g. => wget https://sourceforge.net/projects/raspberry-pi-cross-compilers/files/Raspberry%20Pi%20GCC%20Cross-Compiler%20Toolchains/Buster/GCC%208.3.0/Raspberry%20Pi%202%2C%203/cross-gcc-8.3.0-pi_2-3.tar.gz","title":"B. Download Binary"},{"location":"fenice-steeringwheel/development/qt/#c-extract-binary","text":"Once it is downloaded, we can extract it using the following command: tar xf cross-gcc-*.tar.gz","title":"C. Extract Binary"},{"location":"fenice-steeringwheel/development/qt/#6-sync-raspberry-pi-sysroot-most-important","text":"First, let\u2019s move back into the rpi folder as needed for the next sections: cd ~/rpi-qt Now, we need to sync up our sysroot folder with the system files from the Raspberry Pi. We will be using rsync that let us sync (i.e. copy) files from the Raspberry Pi with appropriate permission onto your Host Machine, potentially saving you alot of time. To do this, enter the following commands one by one into your terminal (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : Command 1: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/lib sysroot Command 2: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/include sysroot/usr Command 3: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/usr/lib sysroot/usr Command 4: rsync -avz --rsync-path=\"sudo rsync\" --delete pi@192.168.1.47:/opt/vc sysroot/opt Note: Double check after each of the above commands that all the files have been copied to ~/rpi-qt/sysroot folder. There will be an information message if there were any issues.","title":"6. Sync Raspberry Pi sysroot (Most Important)"},{"location":"fenice-steeringwheel/development/qt/#7-fix-symbolic-links","text":"The files we copied in the previous step still have symbolic links pointing to the file system on the Raspberry Pi. We need to alter this so that they become relative links from the new sysroot directory on the host machine. We can do this with a python script, which we can download as follows: wget https://raw.githubusercontent.com/abhiTronix/rpi_rootfs/master/scripts/sysroot-relativelinks.py Once it is downloaded, you just need to make it executable and run it, using the following commands: sudo chmod +x sysroot-relativelinks.py ./sysroot-relativelinks.py sysroot","title":"7. Fix symbolic links"},{"location":"fenice-steeringwheel/development/qt/#8-configure-qt-build","text":"Let\u2019s move into the build directory for further steps, as we don\u2019t want to build within that source directory as its crowded, so we will access it from within this this directory: cd ~/rpi-qt/build Finally, Now we can configure our QT build. We need to run the configure script inside QT source to configure our build. Run following command to configure the build, including all the necessary options: CROSS_COMPILER_LOCATION = $HOME /rpi-qt/tools/cross-pi-gcc-* ../qt-everywhere-src-5.15.2/configure -release -opengl es2 -eglfs -device linux-rasp-pi4-v3d-g++ -device-option CROSS_COMPILE = $( echo $CROSS_COMPILER_LOCATION ) /bin/arm-linux-gnueabihf- -sysroot ~/rpi-qt/sysroot/ -prefix /usr/local/qt5.15 -extprefix ~/rpi-qt/qt5.15 -opensource -confirm-license -skip qtscript -skip qtwayland -skip qtwebengine -nomake tests -make libs -pkg-config -no-use-gold-linker -v -recheck -L $HOME /rpi-qt/sysroot/usr/lib/arm-linux-gnueabihf -I $HOME /rpi-qt/sysroot/usr/include/arm-linux-gnueabihf The configure script may take a few minutes to complete.","title":"8. Configure QT Build"},{"location":"fenice-steeringwheel/development/qt/#81-check-configure-output","text":"Once it is completed you should get a summary of what has been configured. Make sure the following options appear: Configure summary: Building on: linux-g++ ( x86_64, CPU features: mmx sse sse2 ) Building for : devices/linux-rasp-pi4-v3d-g++ ( arm, CPU features: neon ) Target compiler: gcc 8 .3.0 Configuration: cross_compile compile_examples enable_new_dtags largefile neon precompile_header shared shared rpath release c++11 c++14 c++17 c++1z concurrent dbus reduce_exports stl","title":"8.1 Check Configure Output"},{"location":"fenice-steeringwheel/development/qt/#82-check-if-eglfs-enabled","text":"QPA backends: EGLFS .................................. yes [ SHOULD BE YES ] EGLFS details: EGLFS OpenWFD ........................ no EGLFS i.Mx6 .......................... no EGLFS i.Mx6 Wayland .................. no EGLFS RCAR ........................... no EGLFS EGLDevice ...................... yes [ SHOULD BE YES ] EGLFS GBM ............................ yes EGLFS VSP2 ........................... no EGLFS Mali ........................... no EGLFS Raspberry Pi ................... no [ SHOULD BE NO ] EGLFS X11 ............................ yes If the your configuration summary doesn\u2019t have the EGLFS features set to what\u2019s shown above, something has probably gone wrong. You can look at the config.log file in the build directory to try and diagnose what the issue might be. If all looks good and all libraries you need have been installed we can continue to the next section","title":"8.2 Check if EGLFS enabled"},{"location":"fenice-steeringwheel/development/qt/#9-build-qt-source","text":"Our build has been configured now, and it is time to actually build the source files, and run the following command: Important: Ensure you are still in the ~/rpi-qt/build directory make -j $( nproc ) Note: -j$(nproc) option indicates that the job should be spread into mutliple threads and run in parallel on available cores. \u2615\ufe0f This process will take some time!","title":"9. Build QT Source"},{"location":"fenice-steeringwheel/development/qt/#10-install-qt-source","text":"Once it is completed, we can install the built package using the following command: make install This should install the files in the correct directories","title":"10. Install QT Source"},{"location":"fenice-steeringwheel/development/qt/#11-deploy-qt-to-raspberry-pi","text":"First move back into the rpi folder using the following command: cd ~/rpi-qt Now, We can now deploy built QT Binaries (contained in ``qt5.15`` folder in ``~/rpi-qt`` directory) back to our Raspberry Pi, again using rsync command. Just run the following command (change ``192.168.1.47`` with the IP address of your Raspberry Pi present on the same network) : rsync -avz --rsync-path = \"sudo rsync\" qt5.15 pi@192.168.1.47:/usr/local","title":"11. Deploy QT to Raspberry Pi"},{"location":"fenice-steeringwheel/development/qt/#final-step-for-target-machine","text":"","title":"Final Step for Target Machine"},{"location":"fenice-steeringwheel/development/qt/#update-linker-on-raspberry-pi","text":"Enter the following command to update the device letting the linker to find the new QT binary files: echo /usr/local/qt5.15/lib | sudo tee /etc/ld.so.conf.d/qt5.15.conf sudo ldconfig For Raspberry Pi 2: If you\u2019re facing issues with running the example, try to use 00-qt5pi.conf instead of qt5pi.conf , in the above command. \ud83c\udf7b That should be it! You have now succesfully installed latest QT 5.15.2 on the Raspberry Pi.","title":"Update linker on Raspberry Pi"},{"location":"fenice-steeringwheel/interface/tabs/","text":"Concept of Tabs","title":"Concept of Tabs"},{"location":"fenice-steeringwheel/interface/tabs/#concept-of-tabs","text":"","title":"Concept of Tabs"},{"location":"fenice-suspension/01-Folder-organization/","text":"Folder organization 2D suspension model In this folder there is a simple 2D model of a suspension, can be used to learn Maple and the kinematics of a suspension mechanism 2D_model_axle_fsolve: file maple of the suspension data_for_2d: file maple of the data suspensions Data_susp: library maple to read data of the suspensions docs In this folder there is the wiki files Fenice suspension model In this folder there is the fenice suspension model","title":"Folder organization"},{"location":"fenice-suspension/01-Folder-organization/#folder-organization","text":"","title":"Folder organization"},{"location":"fenice-suspension/01-Folder-organization/#2d-suspension-model","text":"In this folder there is a simple 2D model of a suspension, can be used to learn Maple and the kinematics of a suspension mechanism 2D_model_axle_fsolve: file maple of the suspension data_for_2d: file maple of the data suspensions Data_susp: library maple to read data of the suspensions","title":"2D suspension model"},{"location":"fenice-suspension/01-Folder-organization/#docs","text":"In this folder there is the wiki files","title":"docs"},{"location":"fenice-suspension/01-Folder-organization/#fenice-suspension-model","text":"In this folder there is the fenice suspension model","title":"Fenice suspension model"},{"location":"fenice-suspension/02-2D-suspension-model/","text":"2D suspension model","title":"2D suspension model"},{"location":"fenice-suspension/02-2D-suspension-model/#2d-suspension-model","text":"","title":"2D suspension model"},{"location":"fenice-suspension/03-Fenice-suspension-model/","text":"Fenice suspension model","title":"Fenice suspension model"},{"location":"fenice-suspension/03-Fenice-suspension-model/#fenice-suspension-model","text":"","title":"Fenice suspension model"},{"location":"fenice-suspension/Home/","text":"Fenice Vehicle Model Welcome to the fenice-suspension wiki! TABLE OF CONTENTS Folder organization 2D suspension model Fenice suspension model","title":"Fenice Vehicle Model"},{"location":"fenice-suspension/Home/#fenice-vehicle-model","text":"Welcome to the fenice-suspension wiki!","title":"Fenice Vehicle Model"},{"location":"fenice-suspension/Home/#table-of-contents","text":"Folder organization 2D suspension model Fenice suspension model","title":"TABLE OF CONTENTS"},{"location":"fenice-traction-control-sw/","text":"Fenice ECU: Traction Control Software The traction control software relies on the following components: The Matlab model (refer to the dynamics team) The Raspberry PI hosting the model and updating it with sensor data from the DAS The DAS module that reads and writes a UART channel with the RPi to communicate with the model Note The choice of running the model on a separate device is for reliability purposes. The car must be able to run even if the model crashes or the RPi breaks / has issues. This documentation is organized in the following sections: Setting up the correct environment on the Raspberry Pi Compiling and running the traction control server","title":"Overview"},{"location":"fenice-traction-control-sw/#fenice-ecu-traction-control-software","text":"The traction control software relies on the following components: The Matlab model (refer to the dynamics team) The Raspberry PI hosting the model and updating it with sensor data from the DAS The DAS module that reads and writes a UART channel with the RPi to communicate with the model Note The choice of running the model on a separate device is for reliability purposes. The car must be able to run even if the model crashes or the RPi breaks / has issues. This documentation is organized in the following sections: Setting up the correct environment on the Raspberry Pi Compiling and running the traction control server","title":"Fenice ECU: Traction Control Software"},{"location":"fenice-traction-control-sw/compiling/","text":"Compiling & Executing The Server Step 1: Install Dependencies To compile the code on the RPi you need to install GCC, Make, glibc_base-dev, and binutils. Install them with: tce-load -wi gcc make glibc_base-dev binutils .","title":"Compiling & Executing"},{"location":"fenice-traction-control-sw/compiling/#compiling-executing-the-server","text":"","title":"Compiling &amp; Executing The Server"},{"location":"fenice-traction-control-sw/compiling/#step-1-install-dependencies","text":"To compile the code on the RPi you need to install GCC, Make, glibc_base-dev, and binutils. Install them with: tce-load -wi gcc make glibc_base-dev binutils .","title":"Step 1: Install Dependencies"},{"location":"fenice-traction-control-sw/rpi-setup/","text":"Operating System In order to obtain maximum performance from the small RPi's CPU, the OS needs to be as lightweight as possible, and needs to support nothing more that a C compiler and serial communication. Core Linux is a distro that ships just a kernel and some core utilities in under 20Mb. Also, it runs completely from RAM, therefore strongly limiting the possibility of failure from SD card wear. Step 1: Download Go to Core Linux's home page and download the Raspberry Pi port, called PiCore : http://www.tinycorelinux.net . If you're not familiar with operating on this type of stripped-down OS, read the booklet or the wiki, both accessible from their website. Step 2: Flash The OS Insert an SD card and flash PiCore with dd : sudo dd if=piCore-13.1.0.img of=/dev/mmcblk0 Step 3: Extend SD Partition By default the storage partition is rather small, so in order to accomodate GCC and other extensions we need to expand it to the full available size: Boot the RPi and log in with user tc and password piCore Run fdisk /dev/mmcblk0 as root Print existing partitions with p and take note of the starting cylinder of the second partition Delete the second partition with d and recreate it with n Use the same starting cylinder as the old partition and maximum available size Write the partition table with w Reboot to make the kernel aware of the changes Now resize the existing filesystem to fill the partition with resize2fs /dev/mmcblk0p2 Step 4: Configure Linux First, set a password that everyone working on the project can remember easily with passwd , like sborato . Since Core runs completely in RAM, such changes won't normally remain after boot, so to make them permanent we need to instruct filetool to backup and restore some files across reboots. To do so, just add their path to /opt/.filetool.lst and trigger a backup by calling filetool.sh -b . In this case, we need to run echo '/etc/shadow' >> /opt/.filetool.lst and trigger the backup. Setp 5: Configure SSH If it's not already installed, run tce-load -wi openssh . To autostart it at every boot, add it to the startup script with sudo echo '/usr/local/etc/init.d/openssh start &' >> /opt/bootlocal.sh Since the filesystem is not persistent, the encryption keys are lost and regenerated at every boot. To make them permanent, add them to the filetool list with sudo echo '/usr/local/etc/ssh' >> /opt/.filetool.lst Trigger the backup with filetool.sh -b Step 6: Disable Bluetooth to Access The Primary UART In RPis with embedded Bluetooth and WiFi, the primary UART is connected to those modules and cannot be used by the user. To remedy that, add dt-overlay=diable-bt and enable_uart=1 to /boot/config.txt . Now, a device named /dev/ttyAMA0 will be available to the user to access the serial interface.","title":"RPi Setup"},{"location":"fenice-traction-control-sw/rpi-setup/#operating-system","text":"In order to obtain maximum performance from the small RPi's CPU, the OS needs to be as lightweight as possible, and needs to support nothing more that a C compiler and serial communication. Core Linux is a distro that ships just a kernel and some core utilities in under 20Mb. Also, it runs completely from RAM, therefore strongly limiting the possibility of failure from SD card wear.","title":"Operating System"},{"location":"fenice-traction-control-sw/rpi-setup/#step-1-download","text":"Go to Core Linux's home page and download the Raspberry Pi port, called PiCore : http://www.tinycorelinux.net . If you're not familiar with operating on this type of stripped-down OS, read the booklet or the wiki, both accessible from their website.","title":"Step 1: Download"},{"location":"fenice-traction-control-sw/rpi-setup/#step-2-flash-the-os","text":"Insert an SD card and flash PiCore with dd : sudo dd if=piCore-13.1.0.img of=/dev/mmcblk0","title":"Step 2: Flash The OS"},{"location":"fenice-traction-control-sw/rpi-setup/#step-3-extend-sd-partition","text":"By default the storage partition is rather small, so in order to accomodate GCC and other extensions we need to expand it to the full available size: Boot the RPi and log in with user tc and password piCore Run fdisk /dev/mmcblk0 as root Print existing partitions with p and take note of the starting cylinder of the second partition Delete the second partition with d and recreate it with n Use the same starting cylinder as the old partition and maximum available size Write the partition table with w Reboot to make the kernel aware of the changes Now resize the existing filesystem to fill the partition with resize2fs /dev/mmcblk0p2","title":"Step 3: Extend SD Partition"},{"location":"fenice-traction-control-sw/rpi-setup/#step-4-configure-linux","text":"First, set a password that everyone working on the project can remember easily with passwd , like sborato . Since Core runs completely in RAM, such changes won't normally remain after boot, so to make them permanent we need to instruct filetool to backup and restore some files across reboots. To do so, just add their path to /opt/.filetool.lst and trigger a backup by calling filetool.sh -b . In this case, we need to run echo '/etc/shadow' >> /opt/.filetool.lst and trigger the backup.","title":"Step 4: Configure Linux"},{"location":"fenice-traction-control-sw/rpi-setup/#setp-5-configure-ssh","text":"If it's not already installed, run tce-load -wi openssh . To autostart it at every boot, add it to the startup script with sudo echo '/usr/local/etc/init.d/openssh start &' >> /opt/bootlocal.sh Since the filesystem is not persistent, the encryption keys are lost and regenerated at every boot. To make them permanent, add them to the filetool list with sudo echo '/usr/local/etc/ssh' >> /opt/.filetool.lst Trigger the backup with filetool.sh -b","title":"Setp 5: Configure SSH"},{"location":"fenice-traction-control-sw/rpi-setup/#step-6-disable-bluetooth-to-access-the-primary-uart","text":"In RPis with embedded Bluetooth and WiFi, the primary UART is connected to those modules and cannot be used by the user. To remedy that, add dt-overlay=diable-bt and enable_uart=1 to /boot/config.txt . Now, a device named /dev/ttyAMA0 will be available to the user to access the serial interface.","title":"Step 6: Disable Bluetooth to Access The Primary UART"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/","text":"Get Started Software to download Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for windows) GitHub setup Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation . Download a repo of the team: Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/fenice-vehicle-model-2022.git Matlab Setup First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Digital Signal Processing Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019. Run Matlab/Simulink Model Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Get Started"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#get-started","text":"","title":"Get Started"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#software-to-download","text":"Visual Studio Code Matlab (version 2022a) Simulink GitBash (only for windows)","title":"Software to download"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#github-setup","text":"Make a Github account with your accademic email (you can link to the same account more emails, so you can add also your personal email address) and send to the CT your git username (if you don't have add it to the form of the recruiting). After being enabled by the CT you can access to the Git of the team in which there are the repositories of the DMT division. Furthermore if you have Windows you will need to download also Git bash . Then to properly set the SSH key to make your computer communicate correctly with the Github portal (both Mac and Windows) Follow these steps: 1) Open Git Bash for Windows or a terminal for Mac 2) check if there is already an existing SSH key with the command ls -al ~/.ssh This command lists the files in your .ssh directory, if they exist. By default, the filenames of supported public keys for GitHub are id_rsa.pub, id_ecdsa.pub, id_ed25519.pub. 3) If there are no existing key, you have to proceed by creating a new one. Paste the text below, substituting in your GitHub email address. ssh-keygen -t ed25519 -C \"your_email@example.com\" 4) When you're prompted to \"Enter a file in which to save the key\" press Enter. This accepts the default file location. 5) At the prompt, type a secure passphrase ( is better to use an empty passphrase ). Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 6) Ensure the ssh-agent is running or start it manually. eval \"$(ssh-agent -s)\" 7) Add your SSH private key to the ssh-agent. If you created your key with a different name, or if you are adding an existing key that has a different name, replace id_ed25519 in the command with the name of your private key file. ssh-add ~/.ssh/id_ed25519 8) Add the SSH key to your account on GitHub. For more information, see \"Adding a new SSH key to your GitHub account\" . If you encountered any problems, take a look at the Official Github documentation .","title":"GitHub setup"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#download-a-repo-of-the-team","text":"Go to the repo of the vehicle model in the Github of the team and click on the button \"Code\" and copy the link for the cloning that you have to paste in the Github desktop app In a Terminal for Mac or with Git Bash for Windows in the folder in which you want to download the repo (usually is useful to create a GitHub folder in which download all the repo): git clone --recurse-submodules git@github.com:eagletrt/fenice-vehicle-model-2022.git","title":"Download a repo of the team:"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#matlab-setup","text":"First of all check that you have installed the correct version of matlab to avoid incompatibility problems when using the files. This first section is crucial for properly setting the Matlab environment so that it can execute the model correctly. These are the toolboxes that you need to install manually: Control System Toolbox Curve Fitting Toolbox Digital Signal Processing Embedded Coder Fuzzy Logic Toolbox MATLAB Coder MinGW-w64 C/C++ Compiler ( only for Windows ) Optimization Toolbox Simscape Simscape Electrical Simscape Multibody Simulink Simulink 3D Animation Simulink Coder Simulink Control Design Symbolic Math Toolbox System Identification Toolbox Clothoids (This latest toolbox and its documentation can be found at https://github.com/ebertolazzi/Clothoids/releases and can be used in place of the folder \u2018 Clothoids \u2019 present in the old vehicle model. We suggest to follow the installation instructions described on the link page given that the toolbox is constantly updated by professor Bertolazzi. During the installation phase, Matlab may require to install an additional package called \u2018 MATLAB Support for MinGW-w64 C/C++ Compiler \u2019.","title":"Matlab Setup"},{"location":"fenice-vehicle-model-2022/01-How-to-get-started/#run-matlabsimulink-model","text":"Open Matlab (after the initial setup described above for first time users) Open the local folder where you have download the repository of the model from GitHub Now on Matlab left coloumn you can open the files and folders of the model, in particular the main.m file!","title":"Run Matlab/Simulink Model"},{"location":"fenice-vehicle-model-2022/02-main.m/","text":"main.m The main file is main.m Type of Simulation At the beginning of the main there is the possibility to assign the variable mod. Assign a number to the variable mod to decide if you want to perform optimization for torque/slip or a standard simulation There is also the possibility to compare the performance and test velocity estimation algorithms Graphics Choice At the beginning of the main file there is also the possibility to decide which graphics we want to plot. Assign a number to the variable The calling of one type of plot corresponds to the calling of one of the three .m files present in the Utilities folder: plots.m (1: all plots), antislipplot.m (2), torquevectoringplot.m (3). So, if you want to modify graphics to modify plots or add new plots for the specific type of plot chosen modify those files, if you want to add another type of plot you have to create a similar file of them and add another option in the main.m file in the Post Processing section. Parameters The main parameters are in the function getSimulationParams : Maneuver type (First argument: a number between 1 and 12): defined in the vehicle inputs section of the Simulink model and inside getsimulationparams: see dedicated section Control types (Second argument: a number between 1 and 4) Sensor Noise (Third argument: Yes(1) or No(2)) Simulation Time: usually, 10 s for slip optimization/slip comparison is useful to reduce it (acceleration maneuver) we need only the starting behaviour for some tv maneuvers, we need instead to increase it and is automatically set in getsimualtionparam (step cornering and ramp steer have fixed simulation time) also for data follow from test is automatically set Motors and controls maps There is the possibility to change the map for the motors (simulating the map chosen by the driver), which impose a maximum torque to the motors (map values between 1 and 6). In the case of the maximum Torque we have developed a function (motorCurve.m in the folder Vehicle Modules) which limits the motor Torque in function of the angular velocity of the wheels and the selected map of the motor. Map 6 is the map that allows the maximum erogable torque . With the parameters map_tv and map_sc (values between 0 and 1) you can select a different level of intensity of the controller action (simulating the map chosen by the driver on the steering wheel), in this way the pilot can even deactivate a control putting it to the lowest value (map_tv/sc = 0) where the contribution of the control goes to zero. Instead map_tv/sc = 1 impose the maximum level for the controls. Other Sections Parameter initialization for the velocity estimation, slip control, torque vectoring: See dedicated sections Parameters for noise In this section there are some estimated values of the variances of the sensor's noise process; these variances are parameters used in the noise injection in Simulink by a random input process in addition to the sensor's signals in Simulink. The noise is selectable in the input part of the getsimulationparam function. Define initial conditions of the simulation In this section are defined the initial conditions for the simulation and the initial conditions for solving the equations of motion. In particular, initial velocity for some maneuvers. Start simulation There is the if cycle which chooses the type of simulation selected with the variable mod at the beginning of the main.m, with embedded graphic options.","title":"main.m"},{"location":"fenice-vehicle-model-2022/02-main.m/#mainm","text":"The main file is main.m","title":"main.m"},{"location":"fenice-vehicle-model-2022/02-main.m/#type-of-simulation","text":"At the beginning of the main there is the possibility to assign the variable mod. Assign a number to the variable mod to decide if you want to perform optimization for torque/slip or a standard simulation There is also the possibility to compare the performance and test velocity estimation algorithms","title":"Type of Simulation"},{"location":"fenice-vehicle-model-2022/02-main.m/#graphics-choice","text":"At the beginning of the main file there is also the possibility to decide which graphics we want to plot. Assign a number to the variable The calling of one type of plot corresponds to the calling of one of the three .m files present in the Utilities folder: plots.m (1: all plots), antislipplot.m (2), torquevectoringplot.m (3). So, if you want to modify graphics to modify plots or add new plots for the specific type of plot chosen modify those files, if you want to add another type of plot you have to create a similar file of them and add another option in the main.m file in the Post Processing section.","title":"Graphics Choice"},{"location":"fenice-vehicle-model-2022/02-main.m/#parameters","text":"The main parameters are in the function getSimulationParams : Maneuver type (First argument: a number between 1 and 12): defined in the vehicle inputs section of the Simulink model and inside getsimulationparams: see dedicated section Control types (Second argument: a number between 1 and 4) Sensor Noise (Third argument: Yes(1) or No(2)) Simulation Time: usually, 10 s for slip optimization/slip comparison is useful to reduce it (acceleration maneuver) we need only the starting behaviour for some tv maneuvers, we need instead to increase it and is automatically set in getsimualtionparam (step cornering and ramp steer have fixed simulation time) also for data follow from test is automatically set","title":"Parameters"},{"location":"fenice-vehicle-model-2022/02-main.m/#motors-and-controls-maps","text":"There is the possibility to change the map for the motors (simulating the map chosen by the driver), which impose a maximum torque to the motors (map values between 1 and 6). In the case of the maximum Torque we have developed a function (motorCurve.m in the folder Vehicle Modules) which limits the motor Torque in function of the angular velocity of the wheels and the selected map of the motor. Map 6 is the map that allows the maximum erogable torque . With the parameters map_tv and map_sc (values between 0 and 1) you can select a different level of intensity of the controller action (simulating the map chosen by the driver on the steering wheel), in this way the pilot can even deactivate a control putting it to the lowest value (map_tv/sc = 0) where the contribution of the control goes to zero. Instead map_tv/sc = 1 impose the maximum level for the controls.","title":"Motors and controls maps"},{"location":"fenice-vehicle-model-2022/02-main.m/#other-sections","text":"Parameter initialization for the velocity estimation, slip control, torque vectoring: See dedicated sections Parameters for noise In this section there are some estimated values of the variances of the sensor's noise process; these variances are parameters used in the noise injection in Simulink by a random input process in addition to the sensor's signals in Simulink. The noise is selectable in the input part of the getsimulationparam function. Define initial conditions of the simulation In this section are defined the initial conditions for the simulation and the initial conditions for solving the equations of motion. In particular, initial velocity for some maneuvers. Start simulation There is the if cycle which chooses the type of simulation selected with the variable mod at the beginning of the main.m, with embedded graphic options.","title":"Other Sections"},{"location":"fenice-vehicle-model-2022/03-initialization.m/","text":"initialization.m The initialization file is initialization.m In this file there is the definition of the path (folders) useful to Matlab to find all the files during its running. Moreover, there is the graphical message that appears when you launch the simulation and some commands to automatically comment subsections of the Simulink model to allow safe exportation of the C code.","title":"initialization.m"},{"location":"fenice-vehicle-model-2022/03-initialization.m/#initializationm","text":"The initialization file is initialization.m In this file there is the definition of the path (folders) useful to Matlab to find all the files during its running. Moreover, there is the graphical message that appears when you launch the simulation and some commands to automatically comment subsections of the Simulink model to allow safe exportation of the C code.","title":"initialization.m"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/","text":"Fenice_VehicleModel.slx The Simulink model is Fenice_VehicleModel.slx The Simulink file is the most important file of the entire model. In the file we have 3 main blocks: the Input block, vehicle model block and the control block. To enter in one of this block you can double click on it or use the tent menu in the upperleft part of the simulink window. Since the controls work at a step size of 10ms we need a resample block in order to resample the data from a 1ms step size to 10ms step size. Input block The vehicle model in order to work needs 3 input values that are the steering angle (transformed in radians after input block), break (values between 0 and 1), throttle (values between 0 and 1). In the input block we can recreate different maneuvers by setting directly the 3 input variables using a signal generator. Alternatively, we can set the desired velocity using a signal generator that enters into a cruise control in order to get the break and throttle signal. In the block we have 12 maneuvers that can be selected directly in the main.m file. STRAIGHT LINE MANEUVERS: We must have a straight line, otherwise something is wrong 1) Straight line : No driver input (delta, throttle,brake), initial speed ( v_init defined in main) [suggested t_f=5-10 s]. 2) Contant speed : Cruise control on desired speed (v_init), no steering [suggested t_f = 5-10 s] 3) Acceleration : Full throttle from standing start, for slip optimization use t_f lower than 5 s 4) Braking : Acceleration from 0 to 100km/h, at t=5s brake until the car stops. NEED A REVIEW STEERING MANEUVERS 5) Double line change : Two sharp lane changes at t=4s and t=8s at cruise speed set in the main with V_init and delta_des set in getsimulationparam. T_f suggested 10 s 6) Step cornering : Sharp turn (step) [need t_f very high, so it is fixed in getsimparam]. After starting to turn the steering isconstant so the car has to perform circles (v des set in getsimand V_init taken in the main) 7) Ramp steer : Progressive steering increase from straight to max angle (first part is a spiral, then with constant steering the second part is made by circles [t_f fixed at 15 s directly in getsimparam) 8) Line keeping: Deviation from a line starts at velocity v_init (set in the main) up to v_des reached with a ramp of 3 second. At 3 sec the car steers with an angle delta_des and then counter-steers to return to the initial line (v_des, delta_des set in getsimulationparam) 9) Sine steer : Sinusoidal steering input (parameter impose in getsimulationparam) with constant longitudinal speed (equal to v_init, set in the main file) OTHER MANEUVERS 10) As an input we can also use the Data Follower (Maneuver 10) using the data measured on track tests that can be found in the Tests folder. The data must be filtered and cut using the repository for the data analysis. The test file is chosen interactively when the aneuver is started by the user. 11) Logitech Cruise Control : not used anymore 12) For Torque Vectoring optimization the aneuver to use is 12, can be tested also with standard simulation, with v_init take in the main and delta_des in get simulationparam. Otherwise, if we are performing a tuning of TV the parameters are set in tune_PID_for_TV_v 13) Inertia Simulation : maneuever used for analising the benefits of having on-board brakes or motors. Sinusoidal steering with increasing frequency (steering angle and sinusoidal frequency have to be specified in the file Performance_comparison/inertia_comparison.m). Controller block In the control block we have the velocity estimation and 4 blocks: slip control and torque vectoring together, only torque vectoring, only slip control and no control. The 4 blocks have all the same inputs that come from the vehicle model block, input block and velocity estimation. They can be selected directly in the main.m file. For the description of the two controls read the respective pdf files. The output of the control block provides the two motor torques. An important note, the implementation of this routing is mandatory: all the inputs must flow inside each controller, only after the controller blocks there must be the case function, the reason lies on the Simulink to C exportation procedure. Velocity estimation (inside controller block) Three different algorithms have been developed for the velocity estimation: - Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. - Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW - Raw algorithm : simply the angular velocity * radius of the front wheels. In this block are computed also the maps for the motors to allow an easier code exportation (velocity estimation + maps together). Vehicle model block The vehicle model block is the main block of the model. In this block we can find the 10 Dof vehicle model. This block uses the equation of motion copied from the Maple file and collects all models that can be found in the Vehicle modules folder. From the 10 Dof model we get all the important states of the car like the acceleration, velocity, position but also values of the forces, torques that can be used as output values. The inputs of this block are the torque of the two motors, the steering angle, and the brake signal.","title":"Fenice_VehicleModel.slx"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/#fenice_vehiclemodelslx","text":"The Simulink model is Fenice_VehicleModel.slx The Simulink file is the most important file of the entire model. In the file we have 3 main blocks: the Input block, vehicle model block and the control block. To enter in one of this block you can double click on it or use the tent menu in the upperleft part of the simulink window. Since the controls work at a step size of 10ms we need a resample block in order to resample the data from a 1ms step size to 10ms step size.","title":"Fenice_VehicleModel.slx"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/#input-block","text":"The vehicle model in order to work needs 3 input values that are the steering angle (transformed in radians after input block), break (values between 0 and 1), throttle (values between 0 and 1). In the input block we can recreate different maneuvers by setting directly the 3 input variables using a signal generator. Alternatively, we can set the desired velocity using a signal generator that enters into a cruise control in order to get the break and throttle signal. In the block we have 12 maneuvers that can be selected directly in the main.m file. STRAIGHT LINE MANEUVERS: We must have a straight line, otherwise something is wrong 1) Straight line : No driver input (delta, throttle,brake), initial speed ( v_init defined in main) [suggested t_f=5-10 s]. 2) Contant speed : Cruise control on desired speed (v_init), no steering [suggested t_f = 5-10 s] 3) Acceleration : Full throttle from standing start, for slip optimization use t_f lower than 5 s 4) Braking : Acceleration from 0 to 100km/h, at t=5s brake until the car stops. NEED A REVIEW STEERING MANEUVERS 5) Double line change : Two sharp lane changes at t=4s and t=8s at cruise speed set in the main with V_init and delta_des set in getsimulationparam. T_f suggested 10 s 6) Step cornering : Sharp turn (step) [need t_f very high, so it is fixed in getsimparam]. After starting to turn the steering isconstant so the car has to perform circles (v des set in getsimand V_init taken in the main) 7) Ramp steer : Progressive steering increase from straight to max angle (first part is a spiral, then with constant steering the second part is made by circles [t_f fixed at 15 s directly in getsimparam) 8) Line keeping: Deviation from a line starts at velocity v_init (set in the main) up to v_des reached with a ramp of 3 second. At 3 sec the car steers with an angle delta_des and then counter-steers to return to the initial line (v_des, delta_des set in getsimulationparam) 9) Sine steer : Sinusoidal steering input (parameter impose in getsimulationparam) with constant longitudinal speed (equal to v_init, set in the main file) OTHER MANEUVERS 10) As an input we can also use the Data Follower (Maneuver 10) using the data measured on track tests that can be found in the Tests folder. The data must be filtered and cut using the repository for the data analysis. The test file is chosen interactively when the aneuver is started by the user. 11) Logitech Cruise Control : not used anymore 12) For Torque Vectoring optimization the aneuver to use is 12, can be tested also with standard simulation, with v_init take in the main and delta_des in get simulationparam. Otherwise, if we are performing a tuning of TV the parameters are set in tune_PID_for_TV_v 13) Inertia Simulation : maneuever used for analising the benefits of having on-board brakes or motors. Sinusoidal steering with increasing frequency (steering angle and sinusoidal frequency have to be specified in the file Performance_comparison/inertia_comparison.m).","title":"Input block"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/#controller-block","text":"In the control block we have the velocity estimation and 4 blocks: slip control and torque vectoring together, only torque vectoring, only slip control and no control. The 4 blocks have all the same inputs that come from the vehicle model block, input block and velocity estimation. They can be selected directly in the main.m file. For the description of the two controls read the respective pdf files. The output of the control block provides the two motor torques. An important note, the implementation of this routing is mandatory: all the inputs must flow inside each controller, only after the controller blocks there must be the case function, the reason lies on the Simulink to C exportation procedure.","title":"Controller block"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/#velocity-estimation-inside-controller-block","text":"Three different algorithms have been developed for the velocity estimation: - Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. - Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW - Raw algorithm : simply the angular velocity * radius of the front wheels. In this block are computed also the maps for the motors to allow an easier code exportation (velocity estimation + maps together).","title":"Velocity estimation (inside controller block)"},{"location":"fenice-vehicle-model-2022/04-Fenice_VehicleModel.slx/#vehicle-model-block","text":"The vehicle model block is the main block of the model. In this block we can find the 10 Dof vehicle model. This block uses the equation of motion copied from the Maple file and collects all models that can be found in the Vehicle modules folder. From the 10 Dof model we get all the important states of the car like the acceleration, velocity, position but also values of the forces, torques that can be used as output values. The inputs of this block are the torque of the two motors, the steering angle, and the brake signal.","title":"Vehicle model block"},{"location":"fenice-vehicle-model-2022/05-Slip_Control-%28Folder%29/","text":"Slip_Control (Folder) The Slip Control folder is Slip_Control Optimization: Set the value of mod = 2 in the main In main.m you can change the arguments of getsimulationparams. The PI coefficients of the slip controller are tuned in order to find the maximum velocity of the selected test, starting from different initial velocities, so it is a good choice to select the acceleration maneuver (3 in getsimulationparam, with a low simulation time Ts \\< 5). Run main.m (for changes see the section \u2018 Useful files and possible changes\u2019 ) Useful files and possible changes: Vehicle_Modules/PajeckaModel_Tyres: it contains the model for the longitudinal simulation of the slip Slip_Control (folder): it contains the files for performing the optimization of the parameters (tuning) of the controller Utilities/Antislipplot.m: plot procedure for plotting the relevant outputs from the simulation Slip_Control/wheel_characteristics.m: it plots the wheel behaviour and finds the peak value of the longitudinal force (lambda ref) main.m : In main.m there is the variable mod for imposing the optimization (mod = 2) or a standard simulation (mod = 1). Under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation (the most common maneuver for the slip control is the acceleration maneuver, you can simulate with only the slip controller active of both, you can also simulate noise but this will also influence the steering angle so the car will turn, the final time should stay under 8 because in the acceleration maneuver the car will start to brake because of the definition of the maneuver), under \u2018Parameters for the slip control\u2019 you can change the intensity of the controller actions and the reference values for the optimization and under \u2018Define initial conditions for the simulation\u2019 you can change the initial velocity but pay attention that at low velocities the simulation has problems. Tune_PI_for_slip.m : you can change the options of the minimization if you want to get useful results (increase the MaxIteration), then you can also change the initial guesses and the parameters of the simulation. The results are stored in Slip_Control/Slip_Test/sc_try.txt, if you want to use these results to see the behaviour of the system or to actually make them the default for the controller then make a copy of this file and call it sc_Fenice.txt in the Slip_Control folder, but make sure to keep the old version safe somewhere else. (or change in the main.m file the name of the PID_Gain_Scheduling file with the one you want to try) Fenice_VehicleModel.slx: in Vehicle Controller/Slip Control there is the whole controller logic and there are different controllers that can be used just by substituting one of the commented blocks with the default one ( the default one is the most used ). Note: for the optimization we must use the simplest one that is called \u2018Low-level slip control for optimization\u2019, the best results can be obtained with the default \u2018Low-level Slip Control\u2019, \u2018Cascade Slip Control\u2019 does not work. Inside the default controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Tyres: Pacejka curves Pacejka curves are VERY important for the longitudinal and lateral dynamics of the car: they affect longitudinal and lateral forces and so control actions. Previously there were two types of modelling curves: the new and the old one, the first is the one validated by Matteo Tomasi\u2019s thesis (and it\u2019s simpler, less coefficient in modelling), instead the latter is the one given by Hoosier fitting and it\u2019s more complete. Nowadays inside Vehicle_Modules/PajeckaModel_Tyres you can find all the updated files for the Pacejka curves. These files are provided by PhD student Matteo Larcher and have been introduced to solve all the problems related to the various maneuvers and instability of the machine in certain situations. Inside this folder, there are 3 files referring to different tyre sets fitting from the data provided by the Tyre Testing Consortium. It\u2019s essential to have a perfect tir file to avoid problem with the whole model (attention high risks of modello sborato!!!!!!!) To change the type of curve for the tyre you have to change the loading of the files of the Pacejka model in the following files: 1) Main.m (by changing the variable \u201cpacejkaParams\u201d) Open problems: We are changing tyres and car, so we need the new data fitting (Boscaro tir to be fixed) We can improve the combinate behaviour of the tir file","title":"Slip_Control (Folder)"},{"location":"fenice-vehicle-model-2022/05-Slip_Control-%28Folder%29/#slip_control-folder","text":"The Slip Control folder is Slip_Control","title":"Slip_Control (Folder)"},{"location":"fenice-vehicle-model-2022/05-Slip_Control-%28Folder%29/#optimization","text":"Set the value of mod = 2 in the main In main.m you can change the arguments of getsimulationparams. The PI coefficients of the slip controller are tuned in order to find the maximum velocity of the selected test, starting from different initial velocities, so it is a good choice to select the acceleration maneuver (3 in getsimulationparam, with a low simulation time Ts \\< 5). Run main.m (for changes see the section \u2018 Useful files and possible changes\u2019 ) Useful files and possible changes: Vehicle_Modules/PajeckaModel_Tyres: it contains the model for the longitudinal simulation of the slip Slip_Control (folder): it contains the files for performing the optimization of the parameters (tuning) of the controller Utilities/Antislipplot.m: plot procedure for plotting the relevant outputs from the simulation Slip_Control/wheel_characteristics.m: it plots the wheel behaviour and finds the peak value of the longitudinal force (lambda ref) main.m : In main.m there is the variable mod for imposing the optimization (mod = 2) or a standard simulation (mod = 1). Under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation (the most common maneuver for the slip control is the acceleration maneuver, you can simulate with only the slip controller active of both, you can also simulate noise but this will also influence the steering angle so the car will turn, the final time should stay under 8 because in the acceleration maneuver the car will start to brake because of the definition of the maneuver), under \u2018Parameters for the slip control\u2019 you can change the intensity of the controller actions and the reference values for the optimization and under \u2018Define initial conditions for the simulation\u2019 you can change the initial velocity but pay attention that at low velocities the simulation has problems. Tune_PI_for_slip.m : you can change the options of the minimization if you want to get useful results (increase the MaxIteration), then you can also change the initial guesses and the parameters of the simulation. The results are stored in Slip_Control/Slip_Test/sc_try.txt, if you want to use these results to see the behaviour of the system or to actually make them the default for the controller then make a copy of this file and call it sc_Fenice.txt in the Slip_Control folder, but make sure to keep the old version safe somewhere else. (or change in the main.m file the name of the PID_Gain_Scheduling file with the one you want to try) Fenice_VehicleModel.slx: in Vehicle Controller/Slip Control there is the whole controller logic and there are different controllers that can be used just by substituting one of the commented blocks with the default one ( the default one is the most used ). Note: for the optimization we must use the simplest one that is called \u2018Low-level slip control for optimization\u2019, the best results can be obtained with the default \u2018Low-level Slip Control\u2019, \u2018Cascade Slip Control\u2019 does not work. Inside the default controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities.","title":"Optimization:"},{"location":"fenice-vehicle-model-2022/05-Slip_Control-%28Folder%29/#tyres-pacejka-curves","text":"Pacejka curves are VERY important for the longitudinal and lateral dynamics of the car: they affect longitudinal and lateral forces and so control actions. Previously there were two types of modelling curves: the new and the old one, the first is the one validated by Matteo Tomasi\u2019s thesis (and it\u2019s simpler, less coefficient in modelling), instead the latter is the one given by Hoosier fitting and it\u2019s more complete. Nowadays inside Vehicle_Modules/PajeckaModel_Tyres you can find all the updated files for the Pacejka curves. These files are provided by PhD student Matteo Larcher and have been introduced to solve all the problems related to the various maneuvers and instability of the machine in certain situations. Inside this folder, there are 3 files referring to different tyre sets fitting from the data provided by the Tyre Testing Consortium. It\u2019s essential to have a perfect tir file to avoid problem with the whole model (attention high risks of modello sborato!!!!!!!) To change the type of curve for the tyre you have to change the loading of the files of the Pacejka model in the following files: 1) Main.m (by changing the variable \u201cpacejkaParams\u201d) Open problems: We are changing tyres and car, so we need the new data fitting (Boscaro tir to be fixed) We can improve the combinate behaviour of the tir file","title":"Tyres: Pacejka curves"},{"location":"fenice-vehicle-model-2022/06-Torque_Vectoring-%28Folder%29/","text":"Torque_Vectoring (Folder) The Torque Vectoring (Folder) is Torque_Vectoring PI Controller To set active impose pi_or_fuzzy = 1 in the main.m file All the most important informations are inside the Torque Vectoring folder and in the main Executing the optimization of the PI controller: Modify tune_PID_for_TV.m (and save): modify target crossover frequency, phase margin ecc\u2026 (make sure to save a backup of the default file) Run main.m with mod = 3 and set getsimulationparam (control 3, maneuver 12, a good choice for the time of the simulation can be Ts = 10 s) The simulation creates a new file TV_PI_PM%%_COF%%.txt that has all the gain for the desired filter (inside the folder Torque_Vectoring_test). If the optimization results are very good (good tracking of the step) update the main in the section Parameters for Torque Vectoring : use the name of the new file .txt, but make sure to keep the default version safe somewhere else because the file that is there now has already good results. Useful files and possible changes: main.m: under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation/optimization. You can also set the mod = 3 to start optimization or mod = 1 for a standard simulation Fenice_VehicleModel.slx: in Vehicle Controller/Torque Vectoring there is the whole controller logic and there are different controllers. Inside the PI controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Torque_Vectoring: is the folder that contains all the files for the optimization. For trying new parameters open the file tune_PID_for_TV.m in which you can modify target crossover frequency, phase margin ecc\u2026 1) Then run the simulation with main.m and mod = 3 (it\u2019s connected to Fenice_VehicleModel.slx a Simulink model of the car for tuning). 2) The simulation creates a new file TV_PI_PM%%_COF%%_test.txt that has all the gain for the desired filter. This file is stored in the subfolder Torque_Vectoring/PI/PI_Test. If you want to use these results, correct the main file in the section Parameters for Torque Vectoring (as described above in the optimization section). Fuzzy Controller to set active impose pi_or_fuzzy = 2; in the main.m file The fuzzy logic takes membership function to describe i/o relation. In particular the membership functions are in TV_fuzzy.fis or TV_fuzzy_sideslip.fis (the second file contains also a relation with the side slip angle, the first file is a simplified version of the second). To see or modify them, use from command window the command fuzzyLogicDesigner and import the file in it. Then you can modify membership function shape and also, I/O relation using the rules option. There is a paper in the library of google drive in which are described the membership function and the rules chosen Handling curves (k_us folder inside Torque_Vectoring) To analyze the handling curves and the understeering gradient Kus use mod == 6 in the main.m file with control = 4 and ramp steer maneuver. After the simulation the Kus is computed for different velocities and the handling curves are plotted to be analyzed. The Kus file is saved (in the subfolder test). If it a good result must be replaced modifying the file loadKusTable.m","title":"Torque_Vectoring (Folder)"},{"location":"fenice-vehicle-model-2022/06-Torque_Vectoring-%28Folder%29/#torque_vectoring-folder","text":"The Torque Vectoring (Folder) is Torque_Vectoring","title":"Torque_Vectoring (Folder)"},{"location":"fenice-vehicle-model-2022/06-Torque_Vectoring-%28Folder%29/#pi-controller","text":"To set active impose pi_or_fuzzy = 1 in the main.m file All the most important informations are inside the Torque Vectoring folder and in the main Executing the optimization of the PI controller: Modify tune_PID_for_TV.m (and save): modify target crossover frequency, phase margin ecc\u2026 (make sure to save a backup of the default file) Run main.m with mod = 3 and set getsimulationparam (control 3, maneuver 12, a good choice for the time of the simulation can be Ts = 10 s) The simulation creates a new file TV_PI_PM%%_COF%%.txt that has all the gain for the desired filter (inside the folder Torque_Vectoring_test). If the optimization results are very good (good tracking of the step) update the main in the section Parameters for Torque Vectoring : use the name of the new file .txt, but make sure to keep the default version safe somewhere else because the file that is there now has already good results. Useful files and possible changes: main.m: under section \u2018Simulation parameters\u2019 you can change the parameters of the simulation/optimization. You can also set the mod = 3 to start optimization or mod = 1 for a standard simulation Fenice_VehicleModel.slx: in Vehicle Controller/Torque Vectoring there is the whole controller logic and there are different controllers. Inside the PI controller the parameters of the integral and proportional gains are taken from a table which is the result of the optimization of the performances at different velocities. Torque_Vectoring: is the folder that contains all the files for the optimization. For trying new parameters open the file tune_PID_for_TV.m in which you can modify target crossover frequency, phase margin ecc\u2026 1) Then run the simulation with main.m and mod = 3 (it\u2019s connected to Fenice_VehicleModel.slx a Simulink model of the car for tuning). 2) The simulation creates a new file TV_PI_PM%%_COF%%_test.txt that has all the gain for the desired filter. This file is stored in the subfolder Torque_Vectoring/PI/PI_Test. If you want to use these results, correct the main file in the section Parameters for Torque Vectoring (as described above in the optimization section).","title":"PI Controller"},{"location":"fenice-vehicle-model-2022/06-Torque_Vectoring-%28Folder%29/#fuzzy-controller","text":"to set active impose pi_or_fuzzy = 2; in the main.m file The fuzzy logic takes membership function to describe i/o relation. In particular the membership functions are in TV_fuzzy.fis or TV_fuzzy_sideslip.fis (the second file contains also a relation with the side slip angle, the first file is a simplified version of the second). To see or modify them, use from command window the command fuzzyLogicDesigner and import the file in it. Then you can modify membership function shape and also, I/O relation using the rules option. There is a paper in the library of google drive in which are described the membership function and the rules chosen","title":"Fuzzy Controller"},{"location":"fenice-vehicle-model-2022/06-Torque_Vectoring-%28Folder%29/#handling-curves","text":"(k_us folder inside Torque_Vectoring) To analyze the handling curves and the understeering gradient Kus use mod == 6 in the main.m file with control = 4 and ramp steer maneuver. After the simulation the Kus is computed for different velocities and the handling curves are plotted to be analyzed. The Kus file is saved (in the subfolder test). If it a good result must be replaced modifying the file loadKusTable.m","title":"Handling curves"},{"location":"fenice-vehicle-model-2022/07-Velocity-estimation-%28Folder%29/","text":"Velocity estimation (Folder) The Velocity Estimation Folder is Velocity estimation Algorithms for velocity estimation Three different algorithms have been developed for the velocity estimation: Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW Raw algorithm : simply the angular velocity radius of the front wheels. The default algorithm used in the simulation is the Panzani algorithm because it is more reliable in terms of following the data collected with the GPS in the different tests. Velocity estimation algorithm in the main file: Selection of the velocity estimation algorithm: In the file main.m in the section \u201c Parameter initialization for the velocity estimation \u201d you can set a different value for the variable \u201c vel_alg \u201d which is taken as an input from the function \u201c choose_velocity_est_algorithm \u201d. In the section for velocity estimation of the main, it\u2019s also called a function velocity_filter in which are defined the filters for Panzani and Savaresi alg. Also, in this section you find S_prev = - 2 which set the initial state for the Savaresi algorithm. Comparison of the algorithms: At the beginning of main.m, selecting mod = 5 , you perform the comparison between the 3 different algorithms for V.E. (it automatically calls the function velocity_est_test ) Velocity estimation folder choose_velocity_est_algorithm : uncomments only the algorithm chosen in the main file with the variable vel_alg velocity_est_test : file launched with mod = 5: compares the algorithms estimation velocity_filter : definition of the filter for Panzani and Savaresi, used both in velocity_est_test and in standard simulations. Notes: The cut of frequency of the transfer functions H for the complementary filter (Panzani) and the one for the smoothing of the acceleration data for Savaresi, defined in velocity_filter can be tuned again as soon as we will have other tests. Open work Savaresi must be filtered more accurately","title":"Velocity estimation (Folder)"},{"location":"fenice-vehicle-model-2022/07-Velocity-estimation-%28Folder%29/#velocity-estimation-folder","text":"The Velocity Estimation Folder is Velocity estimation","title":"Velocity estimation (Folder)"},{"location":"fenice-vehicle-model-2022/07-Velocity-estimation-%28Folder%29/#algorithms-for-velocity-estimation","text":"Three different algorithms have been developed for the velocity estimation: Panzani algorithm : to take the most reliable information from different sensors (encoders and accelerometers) we have implemented a complementary filter in the frequency domain. The main idea is to take the velocity of the tires and rely on them for the low frequency information (using a low pass filter), instead for the high frequency (using a high pass filter) can rely on the longitudinal acceleration of the car. The estimated speed is the sum of high and low frequency components. Savaresi algorithm : The algorithm considers 4 states of the car: very low speed, accelerating, constant speed (or softly braking) and braking. Each one relies on different data to estimate the velocity. This algorithm considers the angular velocity of all the wheel. NEED A REVIEW Raw algorithm : simply the angular velocity radius of the front wheels. The default algorithm used in the simulation is the Panzani algorithm because it is more reliable in terms of following the data collected with the GPS in the different tests. Velocity estimation algorithm in the main file: Selection of the velocity estimation algorithm: In the file main.m in the section \u201c Parameter initialization for the velocity estimation \u201d you can set a different value for the variable \u201c vel_alg \u201d which is taken as an input from the function \u201c choose_velocity_est_algorithm \u201d. In the section for velocity estimation of the main, it\u2019s also called a function velocity_filter in which are defined the filters for Panzani and Savaresi alg. Also, in this section you find S_prev = - 2 which set the initial state for the Savaresi algorithm. Comparison of the algorithms: At the beginning of main.m, selecting mod = 5 , you perform the comparison between the 3 different algorithms for V.E. (it automatically calls the function velocity_est_test )","title":"Algorithms for velocity estimation"},{"location":"fenice-vehicle-model-2022/07-Velocity-estimation-%28Folder%29/#velocity-estimation-folder_1","text":"choose_velocity_est_algorithm : uncomments only the algorithm chosen in the main file with the variable vel_alg velocity_est_test : file launched with mod = 5: compares the algorithms estimation velocity_filter : definition of the filter for Panzani and Savaresi, used both in velocity_est_test and in standard simulations. Notes: The cut of frequency of the transfer functions H for the complementary filter (Panzani) and the one for the smoothing of the acceleration data for Savaresi, defined in velocity_filter can be tuned again as soon as we will have other tests. Open work Savaresi must be filtered more accurately","title":"Velocity estimation folder"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/","text":"Performance Comparison The Peformance comparison folder is Performance_comparison The performance comparison simulation runs two different simulations with two different control system setups choosen with interactive tent menu The comparison runs the selected maneuver for both setups and elaborate a different comparison according to the type of maneuver (straight (man 3) or steering (manuevers from 5 to 9 and maneuver 12). Control comparison Straigth maneuver For straight maneuver the only useful maneuver is the 3 (acceleration), to test the quality of the slip control. Steeering maneuvers For steering maneuver the useful maneuvers are 5-6-7-8-9-12,to test the quality of the torque vectoring control. PI/Fuzzy comparison for Toque Vectoring With this comparison you can study the performance of Pi or Fuzzy Controller for Torque Vectoring with all control active or with only Torque Vectoring. ( only for steering maneuvers ) Inertia simulation Simulation used to test the performance of on-board brakes and motors. Aero kit comparison Simulation used to test the performance of the car with different aero kits. A brief explanation on the simulation: we put as input the desired profile velocity u and the desired steering behavior delta, then the model calculates everything: on this model point of view you will find that there is an improvement in position reached (because time of simulation is fixed). Check in Vehicle_data.mat the aero coefficient (these will be given to you by MT team) Run main.m having in mind: What type of coefficient you have on vehicle data ( with or without kit) What type of maneuver you want (in this case you will find the step corner maneuver without any type of control -> you can change it by main.m parameter, see further explanations on that file or the relative report) Once you have run the maneuver, save the workspace with the data of the simulation ( for ex. without kit) After you change the coefficients in vehicle_data, repeat the maneuver and save again the workspace (for ex .with kit) Note: at the end you have to get the files senzakit.mat and conkit.mat into the folder Performance_comparison/Aero_comparison Open main.m and select mod = 4 in order to be able to select this type of comparison. Run and you will obtain the graphics you want. P.S. in this folder you will find also some images of the inputs (u and delta of the step corner maneuver used) and the real paths coming from main ( they are the same you will obtain as trajectory in the comparison, but this time coming from main).","title":"Performance Comparison"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#performance-comparison","text":"The Peformance comparison folder is Performance_comparison The performance comparison simulation runs two different simulations with two different control system setups choosen with interactive tent menu The comparison runs the selected maneuver for both setups and elaborate a different comparison according to the type of maneuver (straight (man 3) or steering (manuevers from 5 to 9 and maneuver 12).","title":"Performance Comparison"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#control-comparison","text":"","title":"Control comparison"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#straigth-maneuver","text":"For straight maneuver the only useful maneuver is the 3 (acceleration), to test the quality of the slip control.","title":"Straigth maneuver"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#steeering-maneuvers","text":"For steering maneuver the useful maneuvers are 5-6-7-8-9-12,to test the quality of the torque vectoring control.","title":"Steeering maneuvers"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#pifuzzy-comparison-for-toque-vectoring","text":"With this comparison you can study the performance of Pi or Fuzzy Controller for Torque Vectoring with all control active or with only Torque Vectoring. ( only for steering maneuvers )","title":"PI/Fuzzy comparison for Toque Vectoring"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#inertia-simulation","text":"Simulation used to test the performance of on-board brakes and motors.","title":"Inertia simulation"},{"location":"fenice-vehicle-model-2022/08-Performance-Comparison/#aero-kit-comparison","text":"Simulation used to test the performance of the car with different aero kits. A brief explanation on the simulation: we put as input the desired profile velocity u and the desired steering behavior delta, then the model calculates everything: on this model point of view you will find that there is an improvement in position reached (because time of simulation is fixed). Check in Vehicle_data.mat the aero coefficient (these will be given to you by MT team) Run main.m having in mind: What type of coefficient you have on vehicle data ( with or without kit) What type of maneuver you want (in this case you will find the step corner maneuver without any type of control -> you can change it by main.m parameter, see further explanations on that file or the relative report) Once you have run the maneuver, save the workspace with the data of the simulation ( for ex. without kit) After you change the coefficients in vehicle_data, repeat the maneuver and save again the workspace (for ex .with kit) Note: at the end you have to get the files senzakit.mat and conkit.mat into the folder Performance_comparison/Aero_comparison Open main.m and select mod = 4 in order to be able to select this type of comparison. Run and you will obtain the graphics you want. P.S. in this folder you will find also some images of the inputs (u and delta of the step corner maneuver used) and the real paths coming from main ( they are the same you will obtain as trajectory in the comparison, but this time coming from main).","title":"Aero kit comparison"},{"location":"fenice-vehicle-model-2022/09-Vehicle_Modules/","text":"Vehicle_Modules (folder) In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description Git submodules The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Vehicle_Modules (folder)"},{"location":"fenice-vehicle-model-2022/09-Vehicle_Modules/#vehicle_modules-folder","text":"In this folder there are all the Matlab functions and/or data that are used in the vehicle model block in the Simulink file (see below), if you want to modify some parts of the vehicle modelling (such as tire behaviour, model of aerodynamic forces, model of contact forces, motor model, vehicle data, ecc.). vehicle_data.m In this file we have all the data of the car needed for the simulation . After every car change, they must be updated. Some values can be obtained only by doing some tests on the physical car. load... .m files In the loadControlData.m file we simply load the values from the vehicle_data.m file needed for the control. In the loadInitialConditions.m file we load the initial conditions. ... model.m files For the different parts of the vehicle, we have some models including the model of the tire. For the description of these models, you can refer to the pdf file \"10 Dof Vehicle Model Updating\". All these equations are exported from Maple\u2019s files. getSimualtionParams\u2026 see maneuvers description","title":"Vehicle_Modules (folder)"},{"location":"fenice-vehicle-model-2022/09-Vehicle_Modules/#git-submodules","text":"The folder Vehicle_modules is common to all the repo of the DMT team. So we built a submodule in order to have all the files updated in all the repo. The submodule is an external small-repo in which is contained the folder Vehicle Modules and it is linked to all our repo. After having done some changes to this folder during your work on a big repository, you will need to open the terminal in the folder of the big-repo you were working on. For those working with Windows, you will need to open the terminal inside the folder of the big repository by right-clicking with the mouse inside the folder and selecting Git Bash to open it. Alternatively, you can open the folder inside Visual Studio Code and select Git Bash as terminal and work directly in there. Then it will be necessary to insert the type of operation you want to perform with this scrip (BOTH FOR MAC AND WINDOWS). If you want to upload the changes you will need to type ./submodule_script push Then after compliting the push operation the small-repo for the vehicle modules is up to date and automatically pulled also in the other big repo of the team DMT. Every day before starting with your work type in a terminal (MAC) or in GitBash windows to pull remote changes. ./submodule_script pull","title":"Git submodules"},{"location":"fenice-vehicle-model-2022/10-Exportation-of-C-code/","text":"C Code In the folder C Code we can find useful files for the conversion of data and exportation to C code. We can find a file to convert matlab data (.m) in (.csv) data. DatacomparisonS_C to compare response from the model and from the controller implemented in C. In this folder the C code generated by building the simulink blocks is placed automatically during the exportation phase. Exportation of C Code The C Code exportation allows us to convert our controls and velocity estimation blocks from Simulink, in order to use the code in the ECU of our car. The whole model has been organised in such a way to allow an easy exportation of the control code that follows has to be implemented on the controller. It has been decided to organise the code with dynamic libraries which are only called when necessary. To do this, the control section in the Simulink model was revised by creating four separate blocks within it. The important thing is that each block takes the same data as input and output to create interchangeable libraries. In order to successfully export the C code from Simulink model for the controller follow these instructions: From Matlab, open the main .m file and run a simulation with mod=1 keeping all control active (always remember to run a simulation before exporting the code!) Open the Simulink .slx file with the model In Apps select Embedded Coder and in the section that opens go to Settings and set the following parameters: In the Code Generation section set: System target file = ert.tlc ; Language = C ; Prioritised objectives = Execution efficiency, Traceability In the Hardware Implementation section set: Device vendor = ARM Compatible ; Device type = ARM7 Every time before exporting the code, check that the input and output variables are correctly defined as ExportedGlobal Select the control block from which we want to extract the code, right-click on the block, C/C++ Code -> Build This Subsystem This process generates a folder with the name of the block that contains several files .c and .h files. If the model is modified, the code generation procedure must be repeated. .CSV files The .csv files are used for testing the C CODE exportation: 1st method: Run main.m file with mode 7 imposing manuevre and control type. The main file will execute the script m_to_csv.mlx that will generate .csv files for testing the controls behaviour in the ECU of the car 2nd method (17/03/2021 update) - Plot method You can use in C_simulink_comp folder the script DatacomparisonS_C.mlx, to import data from Simulink simulation (control_gen_x.mat) and data from C and analyse the plot","title":"C Code"},{"location":"fenice-vehicle-model-2022/10-Exportation-of-C-code/#c-code","text":"In the folder C Code we can find useful files for the conversion of data and exportation to C code. We can find a file to convert matlab data (.m) in (.csv) data. DatacomparisonS_C to compare response from the model and from the controller implemented in C. In this folder the C code generated by building the simulink blocks is placed automatically during the exportation phase.","title":"C Code"},{"location":"fenice-vehicle-model-2022/10-Exportation-of-C-code/#exportation-of-c-code","text":"The C Code exportation allows us to convert our controls and velocity estimation blocks from Simulink, in order to use the code in the ECU of our car. The whole model has been organised in such a way to allow an easy exportation of the control code that follows has to be implemented on the controller. It has been decided to organise the code with dynamic libraries which are only called when necessary. To do this, the control section in the Simulink model was revised by creating four separate blocks within it. The important thing is that each block takes the same data as input and output to create interchangeable libraries. In order to successfully export the C code from Simulink model for the controller follow these instructions: From Matlab, open the main .m file and run a simulation with mod=1 keeping all control active (always remember to run a simulation before exporting the code!) Open the Simulink .slx file with the model In Apps select Embedded Coder and in the section that opens go to Settings and set the following parameters: In the Code Generation section set: System target file = ert.tlc ; Language = C ; Prioritised objectives = Execution efficiency, Traceability In the Hardware Implementation section set: Device vendor = ARM Compatible ; Device type = ARM7 Every time before exporting the code, check that the input and output variables are correctly defined as ExportedGlobal Select the control block from which we want to extract the code, right-click on the block, C/C++ Code -> Build This Subsystem This process generates a folder with the name of the block that contains several files .c and .h files. If the model is modified, the code generation procedure must be repeated.","title":"Exportation of C Code"},{"location":"fenice-vehicle-model-2022/10-Exportation-of-C-code/#csv-files","text":"The .csv files are used for testing the C CODE exportation: 1st method: Run main.m file with mode 7 imposing manuevre and control type. The main file will execute the script m_to_csv.mlx that will generate .csv files for testing the controls behaviour in the ECU of the car 2nd method (17/03/2021 update) - Plot method You can use in C_simulink_comp folder the script DatacomparisonS_C.mlx, to import data from Simulink simulation (control_gen_x.mat) and data from C and analyse the plot","title":".CSV files"},{"location":"fenice-vehicle-model-2022/11-Other-Folders/","text":"Other Folders Longit_Controller and Lateral_Controller These folders are required to model the longitudinal and lateral dynamics of the car. Inside the Lateral_Controller folder there are all the Clothoid\u2019s functions for the computation of the trajectory of the car. Instead, in the Longit_Controller there are the files for loading the PID coefficients used to describe the behaviour of the driver. This PID controller is implemented inside the \u2018Inputs/Driver/Cruise control/Dynamic cruise control\u2019 block of the simulink model and rules the cruise control to provide the right throttle and brake to the model. These parameters are provided only on a set of discrete values and up to 27 m/s but this is not a problem as Simulink will interpolate these values creating a continuous dynamic even for higher speed values. Utilities In this folder you will find some .m files of functions, the ones most used and to put in evidence are the dataAnalysis.m, antislipplot.m the torquevectoringplot.m that are the files in which are defined the plots selectable in the Graphic part of the main (1, 2, 3) and the function to plot the trajectory of the car (car2D). The other files are used for the verification and data analysis.","title":"Other Folders"},{"location":"fenice-vehicle-model-2022/11-Other-Folders/#other-folders","text":"","title":"Other Folders"},{"location":"fenice-vehicle-model-2022/11-Other-Folders/#longit_controller-and-lateral_controller","text":"These folders are required to model the longitudinal and lateral dynamics of the car. Inside the Lateral_Controller folder there are all the Clothoid\u2019s functions for the computation of the trajectory of the car. Instead, in the Longit_Controller there are the files for loading the PID coefficients used to describe the behaviour of the driver. This PID controller is implemented inside the \u2018Inputs/Driver/Cruise control/Dynamic cruise control\u2019 block of the simulink model and rules the cruise control to provide the right throttle and brake to the model. These parameters are provided only on a set of discrete values and up to 27 m/s but this is not a problem as Simulink will interpolate these values creating a continuous dynamic even for higher speed values.","title":"Longit_Controller and Lateral_Controller"},{"location":"fenice-vehicle-model-2022/11-Other-Folders/#utilities","text":"In this folder you will find some .m files of functions, the ones most used and to put in evidence are the dataAnalysis.m, antislipplot.m the torquevectoringplot.m that are the files in which are defined the plots selectable in the Graphic part of the main (1, 2, 3) and the function to plot the trajectory of the car (car2D). The other files are used for the verification and data analysis.","title":"Utilities"},{"location":"fenice-vehicle-model-2022/12-Release-Notes/","text":"Release Notes In this section you will find the updates of the model 28/07/2022: Tested the exportation of C code and fixed the simulink model to allows a better exportation Performan comparison GitHub instead of Google drive for keeping track of the evolution of the model Fixed the csv exportation for testing the c code 14/04/2022: Updated Simulink schematic and removal of useless things (you can find them in the previous version of the model in google drive) Created a new main that allows to perform simulation, optimization, velocity estimation test with the same file and the same Simulink model Changed the pacejka curves Introduced the motor curves, maps for motors and maps for controls Redefined the manuevres Creation of this readme guide 14/03/2022: Updated Fenice\u2019s data Updated Load Transfer Model in order to consider the nonlinear behaviour of the dampers Updated Simulink schematic and removal of useless things","title":"Release Notes"},{"location":"fenice-vehicle-model-2022/12-Release-Notes/#release-notes","text":"In this section you will find the updates of the model 28/07/2022: Tested the exportation of C code and fixed the simulink model to allows a better exportation Performan comparison GitHub instead of Google drive for keeping track of the evolution of the model Fixed the csv exportation for testing the c code 14/04/2022: Updated Simulink schematic and removal of useless things (you can find them in the previous version of the model in google drive) Created a new main that allows to perform simulation, optimization, velocity estimation test with the same file and the same Simulink model Changed the pacejka curves Introduced the motor curves, maps for motors and maps for controls Redefined the manuevres Creation of this readme guide 14/03/2022: Updated Fenice\u2019s data Updated Load Transfer Model in order to consider the nonlinear behaviour of the dampers Updated Simulink schematic and removal of useless things","title":"Release Notes"},{"location":"fenice-vehicle-model-2022/Home/","text":"Fenice Vehicle Model Welcome to the fenice-vehicle-model-2022 wiki! To modify the model, open Fenice_VehicleModel.slx To start a simulation, open main.m TABLE OF CONTENTS How to get started main.m initialization.m Fenice_VehicleModel.slx Slip_Control (Folder) Torque_Vectoring (Folder) Velocity Estimation (Folder) Performance Comparison Vehicle_Modules Exportation of C Code Other Folders Release Notes","title":"Fenice Vehicle Model"},{"location":"fenice-vehicle-model-2022/Home/#fenice-vehicle-model","text":"Welcome to the fenice-vehicle-model-2022 wiki! To modify the model, open Fenice_VehicleModel.slx To start a simulation, open main.m","title":"Fenice Vehicle Model"},{"location":"fenice-vehicle-model-2022/Home/#table-of-contents","text":"How to get started main.m initialization.m Fenice_VehicleModel.slx Slip_Control (Folder) Torque_Vectoring (Folder) Velocity Estimation (Folder) Performance Comparison Vehicle_Modules Exportation of C Code Other Folders Release Notes","title":"TABLE OF CONTENTS"},{"location":"handcart-hw/handcart/","text":"Handcart / Charger","title":"Handcart / Charger"},{"location":"handcart-hw/handcart/#handcart-charger","text":"","title":"Handcart / Charger"},{"location":"handcart-sw/main/","text":"Handcart Documentation Index Structure Resources & Useful links Intro The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge. Abbreviations BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off) The old \"carrellino\" I want to remember the old handcart, that did his job during all these years. Software Overview The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend. The software can be started trough the main.py python script found in backend/ folder. By default, a service can be found in the raspi, namely handcart-backend.service. In the folder utils/ you can find a shell script to reset the service. Backend The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads. Threads The four threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The thread to manage the leds The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM Main thread with FSM The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR. Both the BRUSA and the BMS messages from the CAN have a timeout, that if reached makes the FSM to go back to CHECK STATE:CHECK The presence of BMS and BRUSA is checked, if both are present, goto IDLE STATE:IDLE Both devices are connected and ready to rock, a precharge command is waited. STATE:PRECHARGE A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM will go to READY state. STATE:READY The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages. STATE:CHARGE In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix. STATE:C_DONE The charge is done, TS is still on, waiting for user input. STATE:ERROR Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled The canread object The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables. Flask HTTP server This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread Frontend The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Charts are created using amcharts 4 with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the formListener method that take a form and the partial URL (because we have to send commands only on the /command/ path, so we can avoid things that can't be done). In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format. include/header.html Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge in every moment, independently whether page you are. index.html This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still doesn't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds). error.html and warning.html These two pages just print BMS-HV and Brusa errors and warnings in a table. The createTable method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html . brusa-info.html In this page are displayed some Brusa's flags in a table made as described above. settings.html Here you can modify some parameters, such as the Cut-Off voltage, the maximum current outlet and there's a button to enable or disable the fastcharge. charts.html This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To see all values about a specific chart there is a function called createMultilineChart that will create a chart with many lines as parameters that are in the json (timestamp excluded). Chart functions In addition to chart's creating functions there are some utilities functions in /chart/chartsFun.js : most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better). CSS All styles are in the css/style.css file. Images All used images are in the images/ folder. JavaScript active.js : Contain a little script to check which page is active, in order to highlight it in the left navigation bar. const.js : Contain all constants needed in the whole frontend, to avoid hardcoding. script.js : Contains all other kind of functions; every function has its own parameter's description. status.js : As mentioned before it contains functions to check the devices' status to refresh the top bar. tables.js : As mentioned before it contains all used tables function. Raspberry configuration Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary. Hardware Electrical wiring TS Tractive System Wiring The TS wiring is described in this diagram: The junction box The TS cable that goes from the BRUSA to the accumulator has a connector in order of being able to charge both the Chimera's acc and the Fenice one. This is done by using a custom cable for each accumulator. The connector is inside a junction box. This box also have the TSMPs resistors. The shields of the cables from the accumulator are connected to PE (protective earth) coming from the cable of the BRUSA trough a molex connector. All the cables exiting the junction box are restrained using some cable restrains from lapp. The TSMP The TS measurament points are connected to the TS+ and TS- in the junction box, having a proper resistor in series. The handcart wiring & PCB connectors All the Shutdown cables in the wiring have purple color. RGB TSAL (fake) The TSAL is used to get a visual feedback of the state of the handcart during charging. The original fenice's TSAL has been taken and has been equiped with RGB leds, connetting the mosphet gates to some pins in the raspberry, specifically: - RED_LED = GPIO 12 #31 - GREEN_LED = GPIO 13 #33 - BLUE_LED = GPIO 16 #36 Some cables has been routed from the back of the pcb to a weipu 6 pin female cable-to-cable connector. Then, the male connector is connected to the TSAL. The pin assignment is: 1 - GND 2 - 12V 3 - Red signal 4 - Green signal 5 - Blue signal A view of the soldered cables of the fake TSAL and the fan. The shutdown circuit The shutdown circuit is generated from the PSU, it passes trough a fuse, it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled. Handcart PCB Components list Brusa NLG513 - HV charger Anderson SB 165A-600V - Connector of TS from brusa to accumulator Amphenol AT06-12S - Connector of communication cable to accumulator CGS HSA25 15K G 1731 - TSMP resistors Lapp Oflex FD 90 CV 16mm2 - TS cables TE connector 770680-1 - Connector of brusa communciation Lapp SKINTOP ST-M Cable restrain - Cable restrain for TS cables BRUSA NLG5 Charger deep dive The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS. Serial connection To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\" ChargeStar software With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why. Connecting by CAN Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola). Setup procedure First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke. Finding a good power source Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how much current to absorb. Connecting the accumulator Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart. Connecting brusa to main power Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA. Charge procedure Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and open the AIRs of the accumulator. Backup (Emergency) software Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to. Resources & Useful links Handcart drive folder Frontend REST API Documentation CAN messages reference here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS Diagram links Shutdown and TS diagrams 1 2 Decisions and info EV 4.5.10 Tells that \"Every TS connector outside of a housing must include a pilot contact/interlock line which is part of the shutdown circuit. Housings only used to avoid interlocks are prohibited.\" We have the black connector named \"Anderson\" which connects the brusa to the adaptor caple for the different accumulators, we want to put it in a container beacuse of the fact that TSMP and resistor has to be placed somewhere, and we didn't like the idea of putting them directly on the cables or the connector. This way we can leave it without the interlock connected to the shutdown.","title":"Handcart Documentation"},{"location":"handcart-sw/main/#handcart-documentation","text":"","title":"Handcart Documentation"},{"location":"handcart-sw/main/#index","text":"Structure Resources & Useful links","title":"Index"},{"location":"handcart-sw/main/#intro","text":"The handcart is the device that is responsible of transporting and charging the car's accumulator. It is based on three main components: Brusa NLG513 charger, that is the actual charger Raspberry pi 4 to run the software High Voltage Accumulator The rasp is connected via CAN Bus with the BMS in the accumulator and with the Brusa charger. The software of the handcart is responsible of all the processes to ensure a good and safe charge.","title":"Intro"},{"location":"handcart-sw/main/#abbreviations","text":"BMS, porco, acc -> accumulator HV -> High Voltage rasp -> raspberry FSM -> Finite State Machine TS (on, off) -> Tractive system (HV) (on o off)","title":"Abbreviations"},{"location":"handcart-sw/main/#the-old-carrellino","text":"I want to remember the old handcart, that did his job during all these years.","title":"The old \"carrellino\""},{"location":"handcart-sw/main/#software","text":"","title":"Software"},{"location":"handcart-sw/main/#overview","text":"The software is written in python and javascript. It's divided in two parts, respectively frontend and backend. The backend is responsible to manage the charge and to communicate with the devices, and it also hosts a webserver for the frontend. The software can be started trough the main.py python script found in backend/ folder. By default, a service can be found in the raspi, namely handcart-backend.service. In the folder utils/ you can find a shell script to reset the service.","title":"Overview"},{"location":"handcart-sw/main/#backend","text":"The backend is the part of the software that is responsible to manage the charge and to communicate with the devices, it also hosts a webserver to serve pages and data to the frontend. Basically it is a python script that becomes a process, then it splits itself in three threads.","title":"Backend"},{"location":"handcart-sw/main/#threads","text":"The four threads are: The state machine, aka the main thread The flask webserver The CAN read/write process The thread to manage the leds The three threads have an class istance that they can access which is in shared memory, accessed with a lock. Other types of communication are two queues: A queue for can msg send between FSM thread and CAN thread A queue for can msg recv between FSM thread and CAN thread A queue for command send between web server and the FSM","title":"Threads"},{"location":"handcart-sw/main/#main-thread-with-fsm","text":"The FSM is based on multiple states: CHECK: It is a state where the presence of the BMS and the BRUSA are checked, if they are both present it will pass to next state IDLE: Both devices are connected and ready to rock, a precharge command is waited PRECHARGE: Accumulator is asked TS ON, wait until a confirmation is received READY: Accumulator is in TS ON, brusa is ready, waiting for a charge command CHARGE: The charge is enabled C_DONE: The charge is finished ERROR: An error state, the charge (if enabled) is stopped, the BMS is asked to TS OFF, the PON of brusa is set to OFF Note that in each state there's a check over errors from the can, if an error is found, the next state will be ERROR. Both the BRUSA and the BMS messages from the CAN have a timeout, that if reached makes the FSM to go back to CHECK","title":"Main thread with FSM"},{"location":"handcart-sw/main/#statecheck","text":"The presence of BMS and BRUSA is checked, if both are present, goto IDLE","title":"STATE:CHECK"},{"location":"handcart-sw/main/#stateidle","text":"Both devices are connected and ready to rock, a precharge command is waited.","title":"STATE:IDLE"},{"location":"handcart-sw/main/#stateprecharge","text":"A TS ON can message is sent to BMS HV, which will do the precharge. In this state we will check if the bms will finish the precharge. Once it did so, the FSM will go to READY state.","title":"STATE:PRECHARGE"},{"location":"handcart-sw/main/#stateready","text":"The TS is on, we are waiting to receive the charge command from the webserver. We countinously check the queue for new messages.","title":"STATE:READY"},{"location":"handcart-sw/main/#statecharge","text":"In this state the charge is enabled, to do this, a variable named \"can_forward_enabled\" is set to True. This variable is shared between the FSM trhead and the CAN thread. In the can thread, a check over can_forward_enabled is made, if it's False it will periodically send an empty CAN message to brusa (this is important to keep the link alive, otherwise the brusa will go in an error state if no msgs receivedin 300ms) If it's True, it will send an enable charge command to brusa with the voltage and current settings. For more info check the brusa CAN messages matrix.","title":"STATE:CHARGE"},{"location":"handcart-sw/main/#statec_done","text":"The charge is done, TS is still on, waiting for user input.","title":"STATE:C_DONE"},{"location":"handcart-sw/main/#stateerror","text":"Something triggered an error, we have to turn off everithing that could be dangerous. The method \"staccastacca()\" is called. Where a TS_OFF message both for chimera's and fenice's accumulator is sent. The message is sent until a confirmation about the fact that the TS is OFF is received. In the staccastacca method also the PON is disabled","title":"STATE:ERROR"},{"location":"handcart-sw/main/#the-canread-object","text":"The 'canread' object is an istance of a class that is thought to store all the information of the BMS, BRUSA, CAN and others. It is also used to process all the CAN messages. The CAN thread passes the can messages in the CAN queue and the FSM thread checks for new messages in the queue at each cycle, if so the message is processed in the canread object using a method. The canread object is accessed only by the thread of the FSM, the other threads access a copy of that object that is called shared_data. This is done for safety reason and to assure a fast access without lag to the main thread, as this object contains error state variables.","title":"The canread object"},{"location":"handcart-sw/main/#flask-http-server","text":"This is the server that serve the requests received from the frontend. It uses the shared_data object to retrieve the data from the FSM thread","title":"Flask HTTP server"},{"location":"handcart-sw/main/#frontend","text":"The handcart's frontend is a webapp based on javascript and html, it fetches the data from the backend by doing RESTFUL requests to the backend. Charts are created using amcharts 4 with Javascript method (NOT the JSON method). To use fetches there are some basic method such as the request-create and the POST method to submit data. I strongly recommend you to use the formListener method that take a form and the partial URL (because we have to send commands only on the /command/ path, so we can avoid things that can't be done). In forms I create some hidden parameters to identify the command we want to send and it have to correspond with the json parameters shown in the documentation describing the json format.","title":"Frontend"},{"location":"handcart-sw/main/#includeheaderhtml","text":"Is the top-bar that have all status, number of warnings and errors, and actual value for each parameter needed. The error and warning's counter can be clicked to access the respective pages. Every value in the header are calculated by the js/status.js file, which will be loaded on page loading. There's also a big SHUTDOWN button to turn off the charge in every moment, independently whether page you are.","title":"include/header.html"},{"location":"handcart-sw/main/#indexhtml","text":"This page has six charts: the first on top-left graphically describe the latest voltage values, then you have the charge percentage and the latest current values on the first row. On the second row there are the latest temperature's chart and two charts about cells voltage and temperature that will work only with Fenice (Chimera still doesn't have these values). Data are received by the flask server using a fetch for each chart to fill the previous data (30 zeros to avoid graphical issues) and then another fetch will be called to ask the server the last data, in order to have a live chart (every 2 seconds).","title":"index.html"},{"location":"handcart-sw/main/#errorhtml-and-warninghtml","text":"These two pages just print BMS-HV and Brusa errors and warnings in a table. The createTable method is inside the js/tables.js file and look at the json's parameters to create the table. If you need to print a json with the \"title-parameter\" in one column instead of on a row, follow the method used in brusa-info.html .","title":"error.html and warning.html"},{"location":"handcart-sw/main/#brusa-infohtml","text":"In this page are displayed some Brusa's flags in a table made as described above.","title":"brusa-info.html"},{"location":"handcart-sw/main/#settingshtml","text":"Here you can modify some parameters, such as the Cut-Off voltage, the maximum current outlet and there's a button to enable or disable the fastcharge.","title":"settings.html"},{"location":"handcart-sw/main/#chartshtml","text":"This page can actually display \"more pages\": it depends on the parameter passed using the GET method. This parameter is used to set a title in the page and to decide which chart you want to display. At this point it will automatically check which chart-function it has to call and calls also the functions to update the header's values. Those charts won't refresh automatically: you have to refresh the page to see new data, so you can use the zoom (by clicking in the start position and drag until the end position of the zoom). To see all values about a specific chart there is a function called createMultilineChart that will create a chart with many lines as parameters that are in the json (timestamp excluded).","title":"charts.html"},{"location":"handcart-sw/main/#chart-functions","text":"In addition to chart's creating functions there are some utilities functions in /chart/chartsFun.js : most of them are in this file just to clear the main one and to reuse them if needed, however they contain the more logical part (i.e. how to set the correct color using a percentage or how to set the correct position of each cell value according to the real position - check the image below to understand it better).","title":"Chart functions"},{"location":"handcart-sw/main/#css","text":"All styles are in the css/style.css file.","title":"CSS"},{"location":"handcart-sw/main/#images","text":"All used images are in the images/ folder.","title":"Images"},{"location":"handcart-sw/main/#javascript","text":"active.js : Contain a little script to check which page is active, in order to highlight it in the left navigation bar. const.js : Contain all constants needed in the whole frontend, to avoid hardcoding. script.js : Contains all other kind of functions; every function has its own parameter's description. status.js : As mentioned before it contains functions to check the devices' status to refresh the top bar. tables.js : As mentioned before it contains all used tables function.","title":"JavaScript"},{"location":"handcart-sw/main/#raspberry-configuration","text":"Follow the guide here Rasp config . The password of the raspberry is \"handcartpi\". In the handcart just one CAN bus is necessary.","title":"Raspberry configuration"},{"location":"handcart-sw/main/#hardware","text":"","title":"Hardware"},{"location":"handcart-sw/main/#electrical-wiring","text":"","title":"Electrical wiring"},{"location":"handcart-sw/main/#ts-tractive-system-wiring","text":"The TS wiring is described in this diagram:","title":"TS Tractive System Wiring"},{"location":"handcart-sw/main/#the-junction-box","text":"The TS cable that goes from the BRUSA to the accumulator has a connector in order of being able to charge both the Chimera's acc and the Fenice one. This is done by using a custom cable for each accumulator. The connector is inside a junction box. This box also have the TSMPs resistors. The shields of the cables from the accumulator are connected to PE (protective earth) coming from the cable of the BRUSA trough a molex connector. All the cables exiting the junction box are restrained using some cable restrains from lapp.","title":"The junction box"},{"location":"handcart-sw/main/#the-tsmp","text":"The TS measurament points are connected to the TS+ and TS- in the junction box, having a proper resistor in series.","title":"The TSMP"},{"location":"handcart-sw/main/#the-handcart-wiring-pcb-connectors","text":"All the Shutdown cables in the wiring have purple color.","title":"The handcart wiring &amp; PCB connectors"},{"location":"handcart-sw/main/#rgb-tsal-fake","text":"The TSAL is used to get a visual feedback of the state of the handcart during charging. The original fenice's TSAL has been taken and has been equiped with RGB leds, connetting the mosphet gates to some pins in the raspberry, specifically: - RED_LED = GPIO 12 #31 - GREEN_LED = GPIO 13 #33 - BLUE_LED = GPIO 16 #36 Some cables has been routed from the back of the pcb to a weipu 6 pin female cable-to-cable connector. Then, the male connector is connected to the TSAL. The pin assignment is: 1 - GND 2 - 12V 3 - Red signal 4 - Green signal 5 - Blue signal A view of the soldered cables of the fake TSAL and the fan.","title":"RGB TSAL (fake)"},{"location":"handcart-sw/main/#the-shutdown-circuit","text":"The shutdown circuit is generated from the PSU, it passes trough a fuse, it passes through the mushroom, to a relay which is controlled by the rasp, then TO_CHARGER, which is the interlock of the connector of the brusa, and then FROM_CHARGER to BMS\u2019s SD, then out of the BMS, to the TSMS key, then in to the BMS again to the airs. Note that the PON (Power ON) of the BRUSA is powered from the shutdown circuit, this way, if the shutdown is opened, the BRUSA is instantaneously disabled.","title":"The shutdown circuit"},{"location":"handcart-sw/main/#handcart-pcb","text":"","title":"Handcart PCB"},{"location":"handcart-sw/main/#components-list","text":"Brusa NLG513 - HV charger Anderson SB 165A-600V - Connector of TS from brusa to accumulator Amphenol AT06-12S - Connector of communication cable to accumulator CGS HSA25 15K G 1731 - TSMP resistors Lapp Oflex FD 90 CV 16mm2 - TS cables TE connector 770680-1 - Connector of brusa communciation Lapp SKINTOP ST-M Cable restrain - Cable restrain for TS cables","title":"Components list"},{"location":"handcart-sw/main/#brusa-nlg5-charger-deep-dive","text":"The brusa can be controlled using CAN or can be programmed to be used without the CAN. For our purposes we will control it over CAN BUS.","title":"BRUSA NLG5 Charger deep dive"},{"location":"handcart-sw/main/#serial-connection","text":"To connect with brusa both for debug and/or change the settings we can use the serial interface. To do so, you have to have an USB to serial adapter, connected to the pins of the BRUSA's connector, check the brusa manual. There are specific settings to set up the serial connection, in german they're called anschlusseinstellungen: Baudrate: 19200 Data bits: 8 parity: none stopbits: 1 protocol: Xon/Xoff If you are on windows, let the serial COM settings as default, but edit the putty settings, i got some problems otherwise. Very important : i don't know why, but if you are going to use ChargeStar software you need to change the COM port to COM1, otherwise the brusa will not be recognized by the program. Note that the serial works only if the board on the brusa is fed with 12 volts via the proper pin 2 AUX or with the main power. to use the serial monitor you have to properly connect and setup the serial, then, use putty on windows or minicom on linux to connect to it. You will asked with a pasword, which is \"monitor\"","title":"Serial connection"},{"location":"handcart-sw/main/#chargestar-software","text":"With the ChargeStar software you can program a charging profile, set various parameters and change some configuration of the brusa, see the brusa's manual for all the infos. Via ChargeStar you can also set the mode to CAN, very useful to control the charge via can. The ChargeStar software will run only on Windows XP or Windows Vista, obviously we'll chose XP, you can run a virtual machine on virtualbox and do the USB-passthrough of the serial to USB adapter. I read that somebody had issues with ChargeStar using the 64 bit version of windows, but for me worked fine. Note that i ran in some problems uploading a custom setting to the brusa: sometimes when the settings are uploaded, the brusa gives an NVSRAM CRC error, the only possible fix is reupload the settings to brusa changing some parameters a bit. I'm still not sure which parameter is causing problems, so change them randomly a bit and it should work after some tries. If you see, some input fields don't accept values with the \".\" not sure why.","title":"ChargeStar software"},{"location":"handcart-sw/main/#connecting-by-can","text":"Connecting with CAN allows to monitor the message outputed by the brusa and (if properly configured) to set some parameters for charging. The CAN connection has to end with a 120 Ohm resistor, otherwise the messages will keep bouncing (kinda), trust me, it is necessary. See the full CAN matrix in the manual. By default the CAN is at 500kbps, unless differently specified in config file with ChargeStar. As i saw, brusa send messages just when the PON pin is set to HIGH (>5V). To set and enable the charge via can you have to send periodically a can message named NLG5_CTL see details on the can matrix. Note that the endianess is big (motorola).","title":"Connecting by CAN"},{"location":"handcart-sw/main/#setup-procedure","text":"First, you need to know what you\u2019re doing, you\u2019re going to work with High Voltage both AC and DC, that\u2019s no joke.","title":"Setup procedure"},{"location":"handcart-sw/main/#finding-a-good-power-source","text":"Brusa will be absorbing a maximum of 16A on a 230V AC 50Hz outlet, so a maximum of 3.6kW, if you\u2019re using the tripolar connector there shouldn\u2019t be any problem, otherwise if you\u2019re using the tripolar to standard socket adaptor, make sure to check if the line is properly supporting the load. Usually it would just warm up the cables, but if you\u2019re unlucky this could cause a fire, so BE CAREFUL. Note that it is possible to specify to the BRUSA how much current to absorb.","title":"Finding a good power source"},{"location":"handcart-sw/main/#connecting-the-accumulator","text":"Depending on the accumulator (Chimera or Fenice) you have to choose the right cable. Turn off the TSMS key Turn off the PON switch Connect the accumulator and the brusa with the HV connector. With chimera make sure that it makes a good contact, sometimes the interlock will not be closed properly. Connect the two LV connectors to the accumulator, and the other end to the handcart.","title":"Connecting the accumulator"},{"location":"handcart-sw/main/#connecting-brusa-to-main-power","text":"Once a good power source has been found, connect the brusa to it. You\u2019ll hear a \u201cclick\u201d from the BRUSA.","title":"Connecting brusa to main power"},{"location":"handcart-sw/main/#charge-procedure","text":"Make sure that just the people needed are near the handcart, the presence of an ESO would be ideal in a not official environment, and required in a race environment. Turn ONthe TSMS key. From now on, the system could be at >400 DC volt. Start the charging software, and then, start the charge. In case of any problem, push the red shutdown button in the handcart, this will stop the charge and open the AIRs of the accumulator.","title":"Charge procedure"},{"location":"handcart-sw/main/#backup-emergency-software","text":"Before starting, follow the set up procedure for the handcart. It is necessary to initialize the canbus on the raspberry pi, just execute this script. If you need the handcart working as fast as possible, just download the charge script from github, and execute it on the raspberry pi, you will be guided through the precharge process of the accumulator and the charge settings. !!! Warning : This software is DUMB, if you set a voltage, the brusa will deliver it, be careful!. !!! Warning: at the time of writing (18/09/2021) the script supports just chimera\u2019s accumulator, this can be bypassed by reading the next note. !!! Tip: if you need to bypass the precharge check of the accumulator for any reason, you can set the variable \u201cBYPASS_TS_CHECK\u201d in the script to false, this way the script will not check the presence of the accumulator, and the brusa will work on anything it is attached to.","title":"Backup (Emergency) software"},{"location":"handcart-sw/main/#resources-useful-links","text":"Handcart drive folder Frontend REST API Documentation CAN messages reference here you can find BRUSA's CAN messages For pork's can messages search on other E-Agle's repo Fake pointers in python Python threading API Bootstrap dashboard template JS Charts Rasp config Charge state machine of BMS","title":"Resources &amp; Useful links"},{"location":"handcart-sw/main/#diagram-links","text":"Shutdown and TS diagrams 1 2","title":"Diagram links"},{"location":"handcart-sw/main/#decisions-and-info","text":"EV 4.5.10 Tells that \"Every TS connector outside of a housing must include a pilot contact/interlock line which is part of the shutdown circuit. Housings only used to avoid interlocks are prohibited.\" We have the black connector named \"Anderson\" which connects the brusa to the adaptor caple for the different accumulators, we want to put it in a container beacuse of the fact that TSMP and resistor has to be placed somewhere, and we didn't like the idea of putting them directly on the cables or the connector. This way we can leave it without the interlock connected to the shutdown.","title":"Decisions and info"},{"location":"rasp-shieldV2-config/","text":"Documentation! This page will be published to eagletrt.wiki . For info on how to use the wiki, refer to this guide and have a look around some other wiki pages. Remember to test locally before pushing this folder!","title":"Documentation!"},{"location":"rasp-shieldV2-config/#documentation","text":"This page will be published to eagletrt.wiki . For info on how to use the wiki, refer to this guide and have a look around some other wiki pages. Remember to test locally before pushing this folder!","title":"Documentation!"},{"location":"telemetry/","text":"Telemetry This repo contains telemetry codes allowing to log, send and parse all sensors data flowing in Fenice. This software is able to send and receive data to clients over a wireless connection. Telemetry App allows to communicate with telemetry. Introduction A telemetry software must log every piece of information of a specific system. The data should be saved in a simple and easy to access format. From the data acquired it must be possible to do analisys to detect problems, improve performances or to integrate new features. An important feature is to notify as soon as a problem is detected, allowing for an immediate fix.","title":"Telemetry"},{"location":"telemetry/#telemetry","text":"This repo contains telemetry codes allowing to log, send and parse all sensors data flowing in Fenice. This software is able to send and receive data to clients over a wireless connection. Telemetry App allows to communicate with telemetry.","title":"Telemetry"},{"location":"telemetry/#introduction","text":"A telemetry software must log every piece of information of a specific system. The data should be saved in a simple and easy to access format. From the data acquired it must be possible to do analisys to detect problems, improve performances or to integrate new features. An important feature is to notify as soon as a problem is detected, allowing for an immediate fix.","title":"Introduction"},{"location":"telemetry/Internal%20implementations/connection/","text":"Implement New Connection Type Introduction To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GeneralSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above). Variables list All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<message> buff_send; Methods to implement Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The subscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a message type message and only send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. void receiveMessage(message& msg); The start pub function have to start a PUB connection and then must create a thread calling the pubLoop(); function and return the thread. thread* startPub(); The start sub function have to start a SUB connection and then must create a thread calling the subLoop(); function and return the thread. thread* startSub(); Already implemented methods (in the Connection class) Public methods The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will create a message type message and insert it in the queue. void setData(string id, string data); The start function will start the connection using the parameter given to the init function. thread* start(); Protected methods This function is called by the start pub function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void pubLoop(); This function is called by the start sub function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void subLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData(); Callbacks Set callbacks This function will set the given function to the clbk_on_open variable. void add_on_open(function<void()>); This function will set the given function to the clbk_on_close variable. void add_on_close(function<void(const int& code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int& code, const string& msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const message&)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const string&)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const string&)>); Use callbacks This function will call the clbk_on_open callback. It have to be called when the connection is opened. void on_open(); This function will call the clbk_on_close callback. It have to be called when the connection is closed (also when fatal errors occur). The given code should be 0 if there's no error, otherwise it should be the error code. void on_close(const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It need the error code and the error message. void on_error(const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the sub loop function. It take the received message as a parameter. void on_message(const message& msg); This function will call the clbk_on_subscribe callback. It have to be called when a subscription is done. It take the topic as a parameter. void on_subscribe(const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void on_unsubscribe(const string& topic); Usage Create a connection Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.add_on_[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the pub loop or the sub loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection(); Examples An example of the connection could be seen at src/zmq_connection.cpp , with the associated header at inc/zmq_connection.h . A working test example could be seen at scripts/testZMQ/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes a ZMQ working connection between a publisher and a subscriber comunicating between two different threads.","title":"Implement New Connection Type"},{"location":"telemetry/Internal%20implementations/connection/#implement-new-connection-type","text":"","title":"Implement New Connection Type"},{"location":"telemetry/Internal%20implementations/connection/#introduction","text":"To create a new connection type you should just implement all virtual functions in the abstract Connection class, that is in the inc/connection.h file. Every message has to be of type Generic Message . The structure of this struct is show here below: struct GenericMessage { string topic; string payload; }; To generalize the connection type you have to implement a class that will contain all the things you'll need for the connection, such as the context and the socket. The class you're going to create must inherit from GeneralSocket class, a void class that has been created in the inc/connection.h file. Once you've done so, you can create your connection class, that will inherit from Connection (the abstract class mentioned above).","title":"Introduction"},{"location":"telemetry/Internal%20implementations/connection/#variables-list","text":"All variables are protected and can be accessed from the derived class. The following variables are available: These variables are needed to set up the connection. You can only set them by calling the Connection 's init function, by passing to it them all. string address; // FORMAT EXAMPLE: 127.0.0.1 string port; // FORMAT EXAMPLE: 8080 int openMode; // FORMAT EXAMPLE: PUB/SUB (it's an enum) This is the object mentioned above, where should be stored your custom socket class. GeneralSocket* socket; These variables are checked inside the Connection class, so you have to manage them. For example: the open = true when the connection has started; the done = true when you close the connection; new_data should never be modify, because is managed by the Connection class. bool done; bool open; bool new_data; These variables are used in the Connection class to manage the reading and the writing operation. The mtx is used to lock the variables, so you can't read or write them at the same time; the cv is used to wait for the other thread to finish the operation; the buff_send is used to store the data that will be sent. mutex mtx; condition_variable cv; queue<message> buff_send;","title":"Variables list"},{"location":"telemetry/Internal%20implementations/connection/#methods-to-implement","text":"Here below the list of all the needed methods: The constructor should only call the Connection 's contrsuctor. // in the .cpp file [YOUR_CLASS]::[YOUR_CLASS]() : Connection() { // code here will be executed before the Connection constructor } The destructor should only call the Connection 's destructor and delete all pointers and other allocated variables. // in the .cpp file [YOUR_CLASS]::~[YOUR_CLASS]() { // code here will be executed before the Connection destructor delete [VARIABLE_NAME]; } The close connection function does not need parameter, because all connection items you'll need should be in the GeneralSocket item. In this function you have to manage the connection closing. void closeConnection(); The subscribe function should manage the subscriber's subscription to a spcified topic void subscribe(const string& topic); The subscribe function should manage the subscriber's unsubscription to a specified topic. void unsubscribe(const string& topic); The send message function should take a message type message and only send it. void sendMessage(const message& msg); The receive message function should call the receive function of your connection and save the arguments in the given message type message. void receiveMessage(message& msg); The start pub function have to start a PUB connection and then must create a thread calling the pubLoop(); function and return the thread. thread* startPub(); The start sub function have to start a SUB connection and then must create a thread calling the subLoop(); function and return the thread. thread* startSub();","title":"Methods to implement"},{"location":"telemetry/Internal%20implementations/connection/#already-implemented-methods-in-the-connection-class","text":"","title":"Already implemented methods (in the Connection class)"},{"location":"telemetry/Internal%20implementations/connection/#public-methods","text":"The init function sets the connection's variables. As told before, to set the connection's variables you have to call this function. void init(const string& address, const string& port, const int& openMode); The set data will create a message type message and insert it in the queue. void setData(string id, string data); The start function will start the connection using the parameter given to the init function. thread* start();","title":"Public methods"},{"location":"telemetry/Internal%20implementations/connection/#protected-methods","text":"This function is called by the start pub function. It will loop and check if the queue is not empty, if there's at least one message, it will call your send message function. void pubLoop(); This function is called by the start sub function. It will loop and check if there are messages to receive by calling your receive message function. The received message will be used by clbk_on_message . void subLoop(); This function will reset the connection's variables. void reset(); This function will stop and close the connection calling your close connection function. void stop(); This function will clear the queue. void clearData();","title":"Protected methods"},{"location":"telemetry/Internal%20implementations/connection/#callbacks","text":"","title":"Callbacks"},{"location":"telemetry/Internal%20implementations/connection/#set-callbacks","text":"This function will set the given function to the clbk_on_open variable. void add_on_open(function<void()>); This function will set the given function to the clbk_on_close variable. void add_on_close(function<void(const int& code)>); This function will set the given function to the clbk_on_error variable. void add_on_error(function<void(const int& code, const string& msg)>); This function will set the given function to the clbk_on_message variable. void add_on_message(function<void(const message&)>); This function will set the given function to the clbk_on_subscribe variable. void add_on_subscribe(function<void(const string&)>); This function will set the given function to the clbk_on_unsubscribe variable. void add_on_unsubscribe(function<void(const string&)>);","title":"Set callbacks"},{"location":"telemetry/Internal%20implementations/connection/#use-callbacks","text":"This function will call the clbk_on_open callback. It have to be called when the connection is opened. void on_open(); This function will call the clbk_on_close callback. It have to be called when the connection is closed (also when fatal errors occur). The given code should be 0 if there's no error, otherwise it should be the error code. void on_close(const int& code); This function will call the clbk_on_error callback. It have to be called when an error occurs (remember to handle errors). It need the error code and the error message. void on_error(const int& code, const string& msg); This function will call the clbk_on_message callback. It's used in the sub loop function. It take the received message as a parameter. void on_message(const message& msg); This function will call the clbk_on_subscribe callback. It have to be called when a subscription is done. It take the topic as a parameter. void on_subscribe(const string& topic); This function will call the clbk_on_unsubscribe callback. It have to be called when an unsubscription is done. It take the topic as a parameter. void on_unsubscribe(const string& topic);","title":"Use callbacks"},{"location":"telemetry/Internal%20implementations/connection/#usage","text":"","title":"Usage"},{"location":"telemetry/Internal%20implementations/connection/#create-a-connection","text":"Create a connection object. It will init connection variables. // the name should represent either the publisher or the subscriber [YOUR_CLASS] name; Init the connection. name.init(\"localhost\", \"1883\", PUB); // or name.init(\"localhost\", \"1883\", SUB); Set up the callbacks. // where [CALLBACK] is either open, close, error, message, subscribe, unsubscribe name.add_on_[CALLBACK]([&]() { // do something }); Start the connection. It will automatically run the pub loop or the sub loop , depending on the connection's mode setted in the init function. thread* thread_name = name.start(); Subscribe/unsubscribe to/from a topic or set data. name.subscribe(\"topic\"); // or name.unsubscribe(\"topic\"); // or // the topic should be the ID of the message name.setData(\"topic\", \"data\"); Close the connection. name.closeConnection();","title":"Create a connection"},{"location":"telemetry/Internal%20implementations/connection/#examples","text":"An example of the connection could be seen at src/zmq_connection.cpp , with the associated header at inc/zmq_connection.h . A working test example could be seen at scripts/testZMQ/test.cpp . It's a simple connection that will publish and subscribe to a topic. The example describes a ZMQ working connection between a publisher and a subscriber comunicating between two different threads.","title":"Examples"},{"location":"telemetry/Internal%20implementations/file_transmission/","text":"File transmission This library allows sending and receiving files from telemetry. It is used to send to telemetry binary files that will be flashed on ECUs on the car. Some of the ECUs have the ability to update the firmware via CAN, so the telemetry receives the updated firmware and then flashes it to the correct ECU. Usage Fist establish a connection between sender and receiver. Then instantiate a transaction object: FileTransfer::FileTransferManager::transaction_t; There are two constructors, one for the sender and one for the receiver. Basically you must setup filename and destination path. And max_chunk_size (in bytes), a connection pointer, and a callback function. The callback function is used to notify the user about the events. A callback example is: file_transfer_callback callback = []( const int & id_ , TRANSACTION_EVENT event ){ cout << \"Transaction <\" << id << \"> event: \" << TRANSACTION_EVENT_STRING [ event ] << endl ; }; The FileTransferManager class is used to manage the transactions. Instantiate a FileTransfer::FileTransferManager object. This can be global as it can handle multiple file transfers (both send and receive). FileTransfer :: FileTransferManager ftm ; Send To start a file transfer for sending: Call FileTransfer::FileTransferManager::send(). The send function handles all the sending process, it creates a thread and returns the id of the transaction. The sending thread can fill the queue with messages, but checks the queue rememaining size before sending, to avoid messages being dropped. Create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the sender constructor: FileTransfer :: FileTransferManager :: transaction_t transaction ( \"bin/telemetry\" , // filename \"bin\" , // destination path & conn , // connection pointer \"file_transfer\" , // topic 4096 , // max_chunk_size in bytes callback // callback function ); Then simply to start sending the file: int transaction_id = ftm . send ( transaction ); if ( transaction_id == -1 ){ printf ( \"Failed to send file \\n\\r \" ); } The send sequence is: The transaction begin mesage is sent. File chunks are sent in order. The transaction end message is sent. Transaction begin message { \"filename\" : \"telemetry\" , \"dest_path\" : \"bin/\" , \"total_chunks\" : 1000 , \"transaction_hash\" : 000 } The transaction hash is done on filename and destination path, so two transactions can have the same hash. Total chunks is the number of chunks that will be sent. Chunk message { \"chunk_n\" : 1 , \"chunk_total\" : 1 , \"transaction_hash\" : 000 , \"data\" : \"chunk data\" } Transaction end message { \"transaction_hash\" : 000 ; } Receive A receiving transaction is defined by the topic_begin, from that message you can get the filename, destination path and total_chunks. When receiving topic_begin call FileTransfer::FileTransferManager::init_receive(). Each time you receive a topic you can get the chunk_id and the data, and call FileTransfer::FileTransferManager::receive(). The transaction end is notified by the topic_end message. When the transaction is finished you can call FileTransfer::FileTransferManager::end_receive(). This function can return false if not all chunks were received. The receiver must handle the link beween the transaction hash and the transaction id. A simple way is to use a hash table. // key: transaction hash // value: transaction id std :: unordered_map < int , int > transfers ; When receiving a transaction begin message, create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the receiver constructor: FileTransfer :: FileTransferManager :: transaction_t rcv_transaction ( message . filename , message . dest_path , message . total_chunks , callback ); Then initialize the receiving transaction and save the transaction id: int id = ftm . init_receive ( rcv_transaction ); if ( id != -1 ){ transfers . insert ({ message . transaction_hash , id }); printf ( \"<%d> -> %s \\n\\r \" , message . transaction_hash , message . filename . c_str ()); } else { printf ( \"Failed to receive file %s \\n\\r \" , message . filename . c_str ()); } When receiving a chunk message, check if the transaction id is in the hash table. If it is, then save the chunk: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ! ftm . receive ( it -> second , msg )){ printf ( \"FileTranferManager did not find transaction\" ); } else { printf ( \"<%d> received chunk %d of %d: %f \\n \" , chunk . transaction_hash , chunk . chunk_n , chunk . chunk_total , ( float ) chunk . chunk_n / chunk . chunk_total ); } } else { printf ( \"Transaction id unrecognized %d \\n\\r \" , chunk . transaction_hash ); } When receiving a transaction end message, check if the transaction id is in the hash table. If it is, then finish the transaction: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ftm . end_receive ( it -> second )){ transfers . erase ( it ); printf ( \"<%d> -> End \\n\\r \" , chunk . transaction_hash ); } else { printf ( \"<%d> -> FAILED end receive \\n\\r \" , chunk . transaction_hash ); } } else { printf ( \"End transaction failed \\n\\r \" ); }","title":"File transmission"},{"location":"telemetry/Internal%20implementations/file_transmission/#file-transmission","text":"This library allows sending and receiving files from telemetry. It is used to send to telemetry binary files that will be flashed on ECUs on the car. Some of the ECUs have the ability to update the firmware via CAN, so the telemetry receives the updated firmware and then flashes it to the correct ECU.","title":"File transmission"},{"location":"telemetry/Internal%20implementations/file_transmission/#usage","text":"Fist establish a connection between sender and receiver. Then instantiate a transaction object: FileTransfer::FileTransferManager::transaction_t; There are two constructors, one for the sender and one for the receiver. Basically you must setup filename and destination path. And max_chunk_size (in bytes), a connection pointer, and a callback function. The callback function is used to notify the user about the events. A callback example is: file_transfer_callback callback = []( const int & id_ , TRANSACTION_EVENT event ){ cout << \"Transaction <\" << id << \"> event: \" << TRANSACTION_EVENT_STRING [ event ] << endl ; }; The FileTransferManager class is used to manage the transactions. Instantiate a FileTransfer::FileTransferManager object. This can be global as it can handle multiple file transfers (both send and receive). FileTransfer :: FileTransferManager ftm ;","title":"Usage"},{"location":"telemetry/Internal%20implementations/file_transmission/#send","text":"To start a file transfer for sending: Call FileTransfer::FileTransferManager::send(). The send function handles all the sending process, it creates a thread and returns the id of the transaction. The sending thread can fill the queue with messages, but checks the queue rememaining size before sending, to avoid messages being dropped. Create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the sender constructor: FileTransfer :: FileTransferManager :: transaction_t transaction ( \"bin/telemetry\" , // filename \"bin\" , // destination path & conn , // connection pointer \"file_transfer\" , // topic 4096 , // max_chunk_size in bytes callback // callback function ); Then simply to start sending the file: int transaction_id = ftm . send ( transaction ); if ( transaction_id == -1 ){ printf ( \"Failed to send file \\n\\r \" ); } The send sequence is: The transaction begin mesage is sent. File chunks are sent in order. The transaction end message is sent. Transaction begin message { \"filename\" : \"telemetry\" , \"dest_path\" : \"bin/\" , \"total_chunks\" : 1000 , \"transaction_hash\" : 000 } The transaction hash is done on filename and destination path, so two transactions can have the same hash. Total chunks is the number of chunks that will be sent. Chunk message { \"chunk_n\" : 1 , \"chunk_total\" : 1 , \"transaction_hash\" : 000 , \"data\" : \"chunk data\" } Transaction end message { \"transaction_hash\" : 000 ; }","title":"Send"},{"location":"telemetry/Internal%20implementations/file_transmission/#receive","text":"A receiving transaction is defined by the topic_begin, from that message you can get the filename, destination path and total_chunks. When receiving topic_begin call FileTransfer::FileTransferManager::init_receive(). Each time you receive a topic you can get the chunk_id and the data, and call FileTransfer::FileTransferManager::receive(). The transaction end is notified by the topic_end message. When the transaction is finished you can call FileTransfer::FileTransferManager::end_receive(). This function can return false if not all chunks were received. The receiver must handle the link beween the transaction hash and the transaction id. A simple way is to use a hash table. // key: transaction hash // value: transaction id std :: unordered_map < int , int > transfers ; When receiving a transaction begin message, create a transaction object: FileTransfer::FileTransferManager::transaction_t; with the receiver constructor: FileTransfer :: FileTransferManager :: transaction_t rcv_transaction ( message . filename , message . dest_path , message . total_chunks , callback ); Then initialize the receiving transaction and save the transaction id: int id = ftm . init_receive ( rcv_transaction ); if ( id != -1 ){ transfers . insert ({ message . transaction_hash , id }); printf ( \"<%d> -> %s \\n\\r \" , message . transaction_hash , message . filename . c_str ()); } else { printf ( \"Failed to receive file %s \\n\\r \" , message . filename . c_str ()); } When receiving a chunk message, check if the transaction id is in the hash table. If it is, then save the chunk: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ! ftm . receive ( it -> second , msg )){ printf ( \"FileTranferManager did not find transaction\" ); } else { printf ( \"<%d> received chunk %d of %d: %f \\n \" , chunk . transaction_hash , chunk . chunk_n , chunk . chunk_total , ( float ) chunk . chunk_n / chunk . chunk_total ); } } else { printf ( \"Transaction id unrecognized %d \\n\\r \" , chunk . transaction_hash ); } When receiving a transaction end message, check if the transaction id is in the hash table. If it is, then finish the transaction: auto it = transfers . find ( chunk . transaction_hash ); if ( it != transfers . end ()){ if ( ftm . end_receive ( it -> second )){ transfers . erase ( it ); printf ( \"<%d> -> End \\n\\r \" , chunk . transaction_hash ); } else { printf ( \"<%d> -> FAILED end receive \\n\\r \" , chunk . transaction_hash ); } } else { printf ( \"End transaction failed \\n\\r \" ); }","title":"Receive"},{"location":"telemetry/Internal%20implementations/json_loading/","text":"Json Loading Telemetry heavily relies on JSON files to store configurations and to send messages. From c++ lots of libraries are used to serialize and deserialize the data, this is a bit of a pain to use. One of the fastest JSON libraries is rapidjson . It is important to be able to load all JSON files/messages in a fast and easy way, checking if they are valid to avoid errors. Because of this a code generator was implemented to generate c++ structs thar represents the JSON files, and with them also all the other utility functions. Including int project In only one file define these macro to enable the json loader definitions in the project: #define __JSON_LOADER_DEFINITION__ #define __MESSAGES_JSON_IMPLEMENTATION__ Where MESSAGES is the header file of the messages. Struct Generation Supported types are: int double string bool vectors objects and vector of objects (also multiple levels of nesting) Simple JSON This JSON: { \"Messages\" : 351245 , \"Average_Frequency_Hz\" : 3078 , \"Duration_seconds\" : 114.093 } Will generate the following c++ struct: typedef struct stat_json { int Messages ; int Average_Frequency_Hz ; double Duration_seconds ; } stat_json ; Where stat_json is the filename used in the code generator. Complex JSON This JSON: { \"type\" : \"telemetry_status\" , \"timestamp\" : 0.0 , \"data\" : 1 , \"msgs_per_second\" : [ { \"device\" : \"name\" , \"count\" : 1 } ], \"camera_status\" : \"fail\" , \"cpu_process_load\" : 10 } Will generate the following c++ structs: typedef struct msgs_per_second_o { std :: string device ; int count ; } msgs_per_second_o ; typedef struct telemetry_status { std :: string type ; double timestamp ; int data ; std :: vector < msgs_per_second_o > msgs_per_second ; std :: string camera_status ; int cpu_process_load ; } telemetry_status ; Logging If the application is using logging functions the JSON loader exposes a macro to define the log function that will be used to log messages, for example when checking JSON. Default log function is: #ifndef JSON_LOG_FUNC #define JSON_LOG_FUNC(msg) std::cout << msg << std::endl; #endif Functions The so called main structs are the struct of the first level of nesting. These are the only one that can use LoadJson, SaveJson, StructToString, and StringToStruct. // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // ---- Main structs only ---- // // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); template < class T > std :: string StructToString ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); CheckJson checks if all the required fields are present in the JSON file, doesn't throw any exceptions but returns false if any of the required fields is missing. The missing fields are logged using JSON_LOG_FUNC . LoadStruct loads a JSON file and deserializes it into a struct. Before loading the JSON file it checks if it is valid. If it is not valid it logs the error using JSON_LOG_FUNC . If the JSON has some missing fileds it will still load all the valid one. SaveStruct saves a struct into a JSON file. StructToString converts a struct to a string. StringToStruct converts a JSON formatted string to a struct, as always checks the JSON before deserializing. Deserialize deserializes a JSON file into a struct. Serialize serializes a struct into a JSON file.","title":"Json Loading"},{"location":"telemetry/Internal%20implementations/json_loading/#json-loading","text":"Telemetry heavily relies on JSON files to store configurations and to send messages. From c++ lots of libraries are used to serialize and deserialize the data, this is a bit of a pain to use. One of the fastest JSON libraries is rapidjson . It is important to be able to load all JSON files/messages in a fast and easy way, checking if they are valid to avoid errors. Because of this a code generator was implemented to generate c++ structs thar represents the JSON files, and with them also all the other utility functions.","title":"Json Loading"},{"location":"telemetry/Internal%20implementations/json_loading/#including-int-project","text":"In only one file define these macro to enable the json loader definitions in the project: #define __JSON_LOADER_DEFINITION__ #define __MESSAGES_JSON_IMPLEMENTATION__ Where MESSAGES is the header file of the messages.","title":"Including int project"},{"location":"telemetry/Internal%20implementations/json_loading/#struct-generation","text":"Supported types are: int double string bool vectors objects and vector of objects (also multiple levels of nesting)","title":"Struct Generation"},{"location":"telemetry/Internal%20implementations/json_loading/#simple-json","text":"This JSON: { \"Messages\" : 351245 , \"Average_Frequency_Hz\" : 3078 , \"Duration_seconds\" : 114.093 } Will generate the following c++ struct: typedef struct stat_json { int Messages ; int Average_Frequency_Hz ; double Duration_seconds ; } stat_json ; Where stat_json is the filename used in the code generator.","title":"Simple JSON"},{"location":"telemetry/Internal%20implementations/json_loading/#complex-json","text":"This JSON: { \"type\" : \"telemetry_status\" , \"timestamp\" : 0.0 , \"data\" : 1 , \"msgs_per_second\" : [ { \"device\" : \"name\" , \"count\" : 1 } ], \"camera_status\" : \"fail\" , \"cpu_process_load\" : 10 } Will generate the following c++ structs: typedef struct msgs_per_second_o { std :: string device ; int count ; } msgs_per_second_o ; typedef struct telemetry_status { std :: string type ; double timestamp ; int data ; std :: vector < msgs_per_second_o > msgs_per_second ; std :: string camera_status ; int cpu_process_load ; } telemetry_status ;","title":"Complex JSON"},{"location":"telemetry/Internal%20implementations/json_loading/#logging","text":"If the application is using logging functions the JSON loader exposes a macro to define the log function that will be used to log messages, for example when checking JSON. Default log function is: #ifndef JSON_LOG_FUNC #define JSON_LOG_FUNC(msg) std::cout << msg << std::endl; #endif","title":"Logging"},{"location":"telemetry/Internal%20implementations/json_loading/#functions","text":"The so called main structs are the struct of the first level of nesting. These are the only one that can use LoadJson, SaveJson, StructToString, and StringToStruct. // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // ---- Main structs only ---- // // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); template < class T > std :: string StructToString ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); CheckJson checks if all the required fields are present in the JSON file, doesn't throw any exceptions but returns false if any of the required fields is missing. The missing fields are logged using JSON_LOG_FUNC . LoadStruct loads a JSON file and deserializes it into a struct. Before loading the JSON file it checks if it is valid. If it is not valid it logs the error using JSON_LOG_FUNC . If the JSON has some missing fileds it will still load all the valid one. SaveStruct saves a struct into a JSON file. StructToString converts a struct to a string. StringToStruct converts a JSON formatted string to a struct, as always checks the JSON before deserializing. Deserialize deserializes a JSON file into a struct. Serialize serializes a struct into a JSON file.","title":"Functions"},{"location":"telemetry/Overview/features/","text":"Features All the features that this repo implemented! Logging The most important feature is to be able to log all data coming from sensors in the car. The raw format, saving every CANbus message as it is, prepending the timestamp. The parsed format, saving directly parsed messages to .CSV files (one for each sensor). Extra information, like date/time, pilot who drove the car, circuit on which was racing on, race type, a specific race configuration, etc... Lastly has been added the onboard video logging, saving a synced video with low resolution and framerate to reduce video size. This helps a lot to recognize which specific race was and mostly reconstruct how the race gone. CSV When the race session ends, from a raw file (only CANbus messages) is really important to be able to generate files containing usable data from the sensors. The most common and simple way to save this kind of data is with CSV files (comma separated values). CSV files are simple to use to be imported and to be procecced. To analyze car performances the team uses Matlab which is kinda slow loading CSV files, a better format for that specific application is .mat, in this repo under python folder there is a script wich converts CSV files to .mat files. Connection Telemetry can transmit data over wireless connection, it uses Websocket (most used) and MQTT, in the future it will also support radio transmission. The connection is used to send status messages to the clients and to receive configurations from the clients. The configurations are used to change the behavior of the telemetry, to enable or disable CSV parsing, enable GPSs, etc... Realtime Data The data is transmitted in realtime, so the user can see the data as it is being received. Sensor data are serialized using Google protobuffers, the serialization and deserialization is implemented in canlib. It can be configured the send rate and the downsample, so reducing the messages sent to the user. Report Really cool feature. Automatic report generator, from a race session generates a PDF file containing plots and basic information about that race, this is really usefull to have a quick analisys of the sensor data, easy to check if sensors were working properly.","title":"Features"},{"location":"telemetry/Overview/features/#features","text":"All the features that this repo implemented!","title":"Features"},{"location":"telemetry/Overview/features/#logging","text":"The most important feature is to be able to log all data coming from sensors in the car. The raw format, saving every CANbus message as it is, prepending the timestamp. The parsed format, saving directly parsed messages to .CSV files (one for each sensor). Extra information, like date/time, pilot who drove the car, circuit on which was racing on, race type, a specific race configuration, etc... Lastly has been added the onboard video logging, saving a synced video with low resolution and framerate to reduce video size. This helps a lot to recognize which specific race was and mostly reconstruct how the race gone.","title":"Logging"},{"location":"telemetry/Overview/features/#csv","text":"When the race session ends, from a raw file (only CANbus messages) is really important to be able to generate files containing usable data from the sensors. The most common and simple way to save this kind of data is with CSV files (comma separated values). CSV files are simple to use to be imported and to be procecced. To analyze car performances the team uses Matlab which is kinda slow loading CSV files, a better format for that specific application is .mat, in this repo under python folder there is a script wich converts CSV files to .mat files.","title":"CSV"},{"location":"telemetry/Overview/features/#connection","text":"Telemetry can transmit data over wireless connection, it uses Websocket (most used) and MQTT, in the future it will also support radio transmission. The connection is used to send status messages to the clients and to receive configurations from the clients. The configurations are used to change the behavior of the telemetry, to enable or disable CSV parsing, enable GPSs, etc...","title":"Connection"},{"location":"telemetry/Overview/features/#realtime-data","text":"The data is transmitted in realtime, so the user can see the data as it is being received. Sensor data are serialized using Google protobuffers, the serialization and deserialization is implemented in canlib. It can be configured the send rate and the downsample, so reducing the messages sent to the user.","title":"Realtime Data"},{"location":"telemetry/Overview/features/#report","text":"Really cool feature. Automatic report generator, from a race session generates a PDF file containing plots and basic information about that race, this is really usefull to have a quick analisys of the sensor data, easy to check if sensors were working properly.","title":"Report"},{"location":"telemetry/Overview/report/","text":"Report When a race finishes it is really important to have an analisys on how the car and the sensors behaved, if some sensors failed and if yes when and why. The best way to have a general view is via graphs. This telemetry feature generates a PDF report containing race informations and basic race stats (max speed etc...) and most importantly plots of every sensor, including GPS trajectories. Here is an example","title":"Report"},{"location":"telemetry/Overview/report/#report","text":"When a race finishes it is really important to have an analisys on how the car and the sensors behaved, if some sensors failed and if yes when and why. The best way to have a general view is via graphs. This telemetry feature generates a PDF report containing race informations and basic race stats (max speed etc...) and most importantly plots of every sensor, including GPS trajectories. Here is an example","title":"Report"},{"location":"telemetry/Setup%20and%20Installation/installation/","text":"Installation Is a large project so it needs some time to be installed properly. Documentation is always not exaustive enough but I'll try my best. This installation procedure is tested and written only for Linux, this is because is developed on Linux and the telemetry software is running on a RaspberryPi, sooo... Clone the repo with git clone --recursive https://github.com/eagletrt/telemetry.git Requirements Required cmake and other stuff to compile the project: sudo apt install build-essential cmake can-utils libboost-iostreams-dev libboost-system-dev libboost-filesystem-dev Required Google Protobuf sudo apt-get install libprotobuf-dev libprotoc-dev Websocketpp git clone git://github.com/zaphoyd/websocketpp.git cd websocketpp cmake . sudo make install GNU PLOT Sorry read the docs to install it git clone https://github.com/dstahlke/gnuplot-iostream.git Raspi Cam git clone https://github.com/rmsalinas/raspicam cd raspicam mkdir build cd build cmake .. make sudo make install sudo ldconfig LibHaru libharu is a submodule in this repo but needs a couple of commands to work properly. cd thirdparty/libharu buildconf.sh ./configure OpenCV This is the latest added so please wait for the installation, OpenCV is a HUGE library but for this project only a tiny part is required. This guide will avoid installing the whole library. Building cd Protobuffer mkdir cpp chmod +X compile ./compile Once all the requirements are installed: mkdir build cd build cmake .. make Most of the times running the cmake and make commands generates lots of errors, please contact the developer to be helped and to allow him to integrate this giude with possible solutions. All the generated binaries are located in bin folder.","title":"Installation"},{"location":"telemetry/Setup%20and%20Installation/installation/#installation","text":"Is a large project so it needs some time to be installed properly. Documentation is always not exaustive enough but I'll try my best. This installation procedure is tested and written only for Linux, this is because is developed on Linux and the telemetry software is running on a RaspberryPi, sooo... Clone the repo with git clone --recursive https://github.com/eagletrt/telemetry.git","title":"Installation"},{"location":"telemetry/Setup%20and%20Installation/installation/#requirements","text":"Required cmake and other stuff to compile the project: sudo apt install build-essential cmake can-utils libboost-iostreams-dev libboost-system-dev libboost-filesystem-dev Required Google Protobuf sudo apt-get install libprotobuf-dev libprotoc-dev Websocketpp git clone git://github.com/zaphoyd/websocketpp.git cd websocketpp cmake . sudo make install GNU PLOT Sorry read the docs to install it git clone https://github.com/dstahlke/gnuplot-iostream.git Raspi Cam git clone https://github.com/rmsalinas/raspicam cd raspicam mkdir build cd build cmake .. make sudo make install sudo ldconfig LibHaru libharu is a submodule in this repo but needs a couple of commands to work properly. cd thirdparty/libharu buildconf.sh ./configure OpenCV This is the latest added so please wait for the installation, OpenCV is a HUGE library but for this project only a tiny part is required. This guide will avoid installing the whole library.","title":"Requirements"},{"location":"telemetry/Setup%20and%20Installation/installation/#building","text":"cd Protobuffer mkdir cpp chmod +X compile ./compile Once all the requirements are installed: mkdir build cd build cmake .. make Most of the times running the cmake and make commands generates lots of errors, please contact the developer to be helped and to allow him to integrate this giude with possible solutions. All the generated binaries are located in bin folder.","title":"Building"},{"location":"telemetry/Setup%20and%20Installation/setup/","text":"Telemetry Usage Running To run check if the device you are using has a CAN interface: ifconfig In the infos displayed make sure can0 / can1 / vcan0 device is shown, if not: if you want to test on an actual CAN interface run bash canSetup.sh , if you want to use a symulated interface run bash vcanSetup.sh . Then to run the actual telemetry use: ./bin/telemetry The script will log lots of informations, check for eventual errors and contact the developer for help. Telemetry generates a debug file in which all the debug/warn/errors are logged. This file is in home folder: ~/telemetry_debug.log . Configurations At the first telemetry run, it generates some .json files that can be used to configure how the code acts. All configs are in home folder ( ~ ). The most important is fenice_telemetry_config.json . fenice_telemetry_config.json field type meaning can_devices vector of objects Each object must contain: - sock: name of the interface (can0 ...) - name: primary/secondary gps_devices vector of objects each entry corresponds to a gps device, objects must have these fields: - addr: port/file name - mode port/file - enabled boolean generate_csv bool enables generation of .csv files while telemetry logs camera_enable bool enables video logging from raspicam connection_enabled bool enables communication over internet (websockets) connection_send_rate int milliseconds between each sensor data ws message connection_send_sensor_data bool enables sending parsed sensor data over ws connection_downsample bool enables downsample of sensors to reduce packet size connection_downsample_mps int mps -> messages per second -> maximum number of messages added in each packet connection object fields: - ip - port - mode WEBSOCKET or ZEROMQ or MQTT to define wich protocol is used example { \"can_devices\" : [ { \"sock\" : \"vcan0\" , \"name\" : \"primary\" }, { \"sock\" : \"vcan1\" , \"name\" : \"secondary\" } ], \"gps_devices\" : [ { \"addr\" : \"/dev/ttyACM1\" , \"mode\" : \"port\" , \"enabled\" : true } ], \"generate_csv\" : true , \"camera_enable\" : true , \"connection_downsample\" : false , \"connection_downsample_mps\" : 40 , \"connection_enabled\" : true , \"connection_send_rate\" : 100 , \"connection_send_sensor_data\" : true , \"connection\" : { \"ip\" : \"telemetry-server.herokuapp.com\" , \"port\" : \"\" , \"mode\" : \"WEBSOCKET\" } } session_config.json Configures a race session. This informations are used to generate folder names for each log session. field type meaning Circuit string name of the race circuit Pilot string name of the pilot Race string type of race ( acceleration/skidpad/trakdrive etc) Configuration string current race configuration, for example test at 40 Km/h or car power map 40 % etc Date string date of the test gg_mm_yyyy Time string time of the test HH:MM:SS example { \"Circuit\" : \"Vadena\" , \"Pilot\" : \"Mirco\" , \"Race\" : \"Half Skidpad (velocit\u00e0 costante)\" , \"Configuration\" : \"Bassa - 40%\" , \"Date\" : \"21_03_2022\" , \"Time\" : \"00:12:49\" } When telemetry starts logging a folder is generated to contain all the current log infos/files. The folder name is constructed like: ~/logs/<date>/<race> [<configuration>] <incremental number>/ Example: ~/logs/14_03_2022/Straight line [40 km h] 7 Where Straight line is field Race , 40 km h is Configuration and 7 is the 7th logging session whith same configurations. Starting Using the telemetry application . Or can be started with a CAN message defined in canlib: SET_TLM_STATUS The can message can be sent from an onboard device, in our case the steering wheel has a button that sends start/stop messages to telemetry. Output The data that telemetry produces can be found in: ~/logs/<date>/<race> [<configuration>] Folder names are explained here . Files that telemetry produces: Raw : - candump.log: contains all raw CAN messages. - gps_n.log: n is the index of the device (index in the vector of gps devices defined in telemetry_config.json ), contains raw strings coming from GPS device. Stats : - CAN_Info.json: json formatted file containing the session infos like Race, Pilot, Configuration and some extra informations about CAN messages: number and frequency during the log session. - gps_n.json: contains date and time of the log and informations about gps messages: number and frequency. CSV : If generate_csv option is enabled, in a subfolder are located a bunch of .csv files, one for each sensor logged. The files are named as the sensor. The first line is a header, contains the column value name. Every other line is the actual sensor value. Example Pedals.csv contains the sensors values of the \"pedals\". Header timestamp,throttle1,throttle2,brake_front,brake_rear, Couple of lines 1637591203.904133,28.000000,68.000000,1.246000,1.112000, 1637591203.913102,30.000000,67.000000,1.246000,1.112000, 1637591203.914190,30.000000,67.000000,1.328000,1.084000, 1637591203.923164,29.000000,67.000000,1.328000,1.084000, 1637591203.924087,29.000000,67.000000,1.302000,1.084000, 1637591203.933217,29.000000,67.000000,1.302000,1.084000, 1637591203.934093,29.000000,67.000000,1.328000,1.112000, 1637591203.943089,30.000000,67.000000,1.328000,1.112000, 1637591203.944154,30.000000,67.000000,1.246000,1.138000, 1637591203.953122,31.000000,65.000000,1.246000,1.138000, 1637591203.954210,31.000000,65.000000,1.246000,1.138000, 1637591203.963181,33.000000,65.000000,1.246000,1.138000, 1637591203.964085,33.000000,65.000000,1.328000,1.138000, Split each line by comma and the result is a vector of values, each column value refers to the column name defined in the header.","title":"Telemetry Usage"},{"location":"telemetry/Setup%20and%20Installation/setup/#telemetry-usage","text":"","title":"Telemetry Usage"},{"location":"telemetry/Setup%20and%20Installation/setup/#running","text":"To run check if the device you are using has a CAN interface: ifconfig In the infos displayed make sure can0 / can1 / vcan0 device is shown, if not: if you want to test on an actual CAN interface run bash canSetup.sh , if you want to use a symulated interface run bash vcanSetup.sh . Then to run the actual telemetry use: ./bin/telemetry The script will log lots of informations, check for eventual errors and contact the developer for help. Telemetry generates a debug file in which all the debug/warn/errors are logged. This file is in home folder: ~/telemetry_debug.log .","title":"Running"},{"location":"telemetry/Setup%20and%20Installation/setup/#configurations","text":"At the first telemetry run, it generates some .json files that can be used to configure how the code acts. All configs are in home folder ( ~ ). The most important is fenice_telemetry_config.json .","title":"Configurations"},{"location":"telemetry/Setup%20and%20Installation/setup/#fenice_telemetry_configjson","text":"field type meaning can_devices vector of objects Each object must contain: - sock: name of the interface (can0 ...) - name: primary/secondary gps_devices vector of objects each entry corresponds to a gps device, objects must have these fields: - addr: port/file name - mode port/file - enabled boolean generate_csv bool enables generation of .csv files while telemetry logs camera_enable bool enables video logging from raspicam connection_enabled bool enables communication over internet (websockets) connection_send_rate int milliseconds between each sensor data ws message connection_send_sensor_data bool enables sending parsed sensor data over ws connection_downsample bool enables downsample of sensors to reduce packet size connection_downsample_mps int mps -> messages per second -> maximum number of messages added in each packet connection object fields: - ip - port - mode WEBSOCKET or ZEROMQ or MQTT to define wich protocol is used example { \"can_devices\" : [ { \"sock\" : \"vcan0\" , \"name\" : \"primary\" }, { \"sock\" : \"vcan1\" , \"name\" : \"secondary\" } ], \"gps_devices\" : [ { \"addr\" : \"/dev/ttyACM1\" , \"mode\" : \"port\" , \"enabled\" : true } ], \"generate_csv\" : true , \"camera_enable\" : true , \"connection_downsample\" : false , \"connection_downsample_mps\" : 40 , \"connection_enabled\" : true , \"connection_send_rate\" : 100 , \"connection_send_sensor_data\" : true , \"connection\" : { \"ip\" : \"telemetry-server.herokuapp.com\" , \"port\" : \"\" , \"mode\" : \"WEBSOCKET\" } }","title":"fenice_telemetry_config.json"},{"location":"telemetry/Setup%20and%20Installation/setup/#session_configjson","text":"Configures a race session. This informations are used to generate folder names for each log session. field type meaning Circuit string name of the race circuit Pilot string name of the pilot Race string type of race ( acceleration/skidpad/trakdrive etc) Configuration string current race configuration, for example test at 40 Km/h or car power map 40 % etc Date string date of the test gg_mm_yyyy Time string time of the test HH:MM:SS example { \"Circuit\" : \"Vadena\" , \"Pilot\" : \"Mirco\" , \"Race\" : \"Half Skidpad (velocit\u00e0 costante)\" , \"Configuration\" : \"Bassa - 40%\" , \"Date\" : \"21_03_2022\" , \"Time\" : \"00:12:49\" } When telemetry starts logging a folder is generated to contain all the current log infos/files. The folder name is constructed like: ~/logs/<date>/<race> [<configuration>] <incremental number>/ Example: ~/logs/14_03_2022/Straight line [40 km h] 7 Where Straight line is field Race , 40 km h is Configuration and 7 is the 7th logging session whith same configurations.","title":"session_config.json"},{"location":"telemetry/Setup%20and%20Installation/setup/#starting","text":"Using the telemetry application . Or can be started with a CAN message defined in canlib: SET_TLM_STATUS The can message can be sent from an onboard device, in our case the steering wheel has a button that sends start/stop messages to telemetry.","title":"Starting"},{"location":"telemetry/Setup%20and%20Installation/setup/#output","text":"The data that telemetry produces can be found in: ~/logs/<date>/<race> [<configuration>] Folder names are explained here . Files that telemetry produces: Raw : - candump.log: contains all raw CAN messages. - gps_n.log: n is the index of the device (index in the vector of gps devices defined in telemetry_config.json ), contains raw strings coming from GPS device. Stats : - CAN_Info.json: json formatted file containing the session infos like Race, Pilot, Configuration and some extra informations about CAN messages: number and frequency during the log session. - gps_n.json: contains date and time of the log and informations about gps messages: number and frequency. CSV : If generate_csv option is enabled, in a subfolder are located a bunch of .csv files, one for each sensor logged. The files are named as the sensor. The first line is a header, contains the column value name. Every other line is the actual sensor value. Example Pedals.csv contains the sensors values of the \"pedals\". Header timestamp,throttle1,throttle2,brake_front,brake_rear, Couple of lines 1637591203.904133,28.000000,68.000000,1.246000,1.112000, 1637591203.913102,30.000000,67.000000,1.246000,1.112000, 1637591203.914190,30.000000,67.000000,1.328000,1.084000, 1637591203.923164,29.000000,67.000000,1.328000,1.084000, 1637591203.924087,29.000000,67.000000,1.302000,1.084000, 1637591203.933217,29.000000,67.000000,1.302000,1.084000, 1637591203.934093,29.000000,67.000000,1.328000,1.112000, 1637591203.943089,30.000000,67.000000,1.328000,1.112000, 1637591203.944154,30.000000,67.000000,1.246000,1.138000, 1637591203.953122,31.000000,65.000000,1.246000,1.138000, 1637591203.954210,31.000000,65.000000,1.246000,1.138000, 1637591203.963181,33.000000,65.000000,1.246000,1.138000, 1637591203.964085,33.000000,65.000000,1.328000,1.138000, Split each line by comma and the result is a vector of values, each column value refers to the column name defined in the header.","title":"Output"},{"location":"telemetry-json-loader/","text":"JSON Loader This project allows generating c++ json loader classes from json files. Given json as input it detects all fields (structs, vectors ...) and generates c++ code for loading them. The json library used is rapidjson Usage Input files are located under json_input , each subfolder will later represent a .h file. Each .json file will be parsed and will be added to the corresponding .h file. These .json file are called Main Structs, and some functions generated supports only Main Structs. Nested structs are called Secondary structs, and cannot be loaded directly. The generated code is placed in out or in branch build. Functions generated // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // If this is a main struct: // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); // If main struct template < class T > std :: string StructToString ( const T & obj ); template < class T > std :: string StructToStringPretty ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); LoadStruct and SaveStruct are directly json to file or file to json. StructToString and StringToStruct are json to string or string to json (used in telemetry for exchanging messages). StructToStringPretty is json to string with pretty formatting. Serialize , Deserialize and CheckJson are internal functions.","title":"JSON Loader"},{"location":"telemetry-json-loader/#json-loader","text":"This project allows generating c++ json loader classes from json files. Given json as input it detects all fields (structs, vectors ...) and generates c++ code for loading them. The json library used is rapidjson","title":"JSON Loader"},{"location":"telemetry-json-loader/#usage","text":"Input files are located under json_input , each subfolder will later represent a .h file. Each .json file will be parsed and will be added to the corresponding .h file. These .json file are called Main Structs, and some functions generated supports only Main Structs. Nested structs are called Secondary structs, and cannot be loaded directly. The generated code is placed in out or in branch build.","title":"Usage"},{"location":"telemetry-json-loader/#functions-generated","text":"// T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > bool CheckJson ( const T & obj , const J & doc ); // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T , class J > void Deserialize ( T & obj , J & doc ); template < class T > void Serialize ( rapidjson :: Document & out , const T & obj ); template < class T > void Serialize ( rapidjson :: Value & out , const T & obj , rapidjson :: Document :: AllocatorType & alloc ); // If this is a main struct: // T is a struct // J is a rapidjson::Document or a rapidjson::Value template < class T > bool LoadStruct ( T & out , const std :: string & path ); template < class T > void SaveStruct ( const T & obj , const std :: string & path ); // If main struct template < class T > std :: string StructToString ( const T & obj ); template < class T > std :: string StructToStringPretty ( const T & obj ); template < class T > bool StringToStruct ( const std :: string & obj_str , T & obj ); LoadStruct and SaveStruct are directly json to file or file to json. StructToString and StringToStruct are json to string or string to json (used in telemetry for exchanging messages). StructToStringPretty is json to string with pretty formatting. Serialize , Deserialize and CheckJson are internal functions.","title":"Functions generated"}]}